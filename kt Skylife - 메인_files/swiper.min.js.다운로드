/**
 * Swiper 5.2.0
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://swiperjs.com
 *
 * Copyright 2014-2019 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: October 26, 2019
 */

!(function (e, t) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = t())
    : typeof define === 'function' && define.amd
    ? define(t)
    : ((e = e || self).Swiper = t())
})(this, function () {
  'use strict'
  const e =
    typeof document === 'undefined'
      ? {
          body: {},
          addEventListener() {},
          removeEventListener() {},
          activeElement: { blur() {}, nodeName: '' },
          querySelector() {
            return null
          },
          querySelectorAll() {
            return []
          },
          getElementById() {
            return null
          },
          createEvent() {
            return { initEvent() {} }
          },
          createElement() {
            return {
              children: [],
              childNodes: [],
              style: {},
              setAttribute() {},
              getElementsByTagName() {
                return []
              },
            }
          },
          location: { hash: '' },
        }
      : document
  const t =
    typeof window === 'undefined'
      ? {
          document: e,
          navigator: { userAgent: '' },
          location: {},
          history: {},
          CustomEvent() {
            return this
          },
          addEventListener() {},
          removeEventListener() {},
          getComputedStyle() {
            return {
              getPropertyValue() {
                return ''
              },
            }
          },
          Image() {},
          Date() {},
          screen: {},
          setTimeout() {},
          clearTimeout() {},
        }
      : window
  const i = function (e) {
    for (let t = 0; t < e.length; t += 1) this[t] = e[t]
    return (this.length = e.length), this
  }
  function s(s, a) {
    const r = []
    let n = 0
    if (s && !a && s instanceof i) return s
    if (s)
      if (typeof s === 'string') {
        let o
        let l
        const d = s.trim()
        if (d.includes('<') && d.includes('>')) {
          let h = 'div'
          for (
            d.indexOf('<li') === 0 && (h = 'ul'),
              d.indexOf('<tr') === 0 && (h = 'tbody'),
              (d.indexOf('<td') !== 0 && d.indexOf('<th') !== 0) || (h = 'tr'),
              d.indexOf('<tbody') === 0 && (h = 'table'),
              d.indexOf('<option') === 0 && (h = 'select'),
              (l = e.createElement(h)).innerHTML = d,
              n = 0;
            n < l.childNodes.length;
            n += 1
          )
            r.push(l.childNodes[n])
        } else
          for (
            o =
              a || s[0] !== '#' || s.match(/[ .<>:~]/)
                ? (a || e).querySelectorAll(s.trim())
                : [e.getElementById(s.trim().split('#')[1])],
              n = 0;
            n < o.length;
            n += 1
          )
            o[n] && r.push(o[n])
      } else if (s.nodeType || s === t || s === e) r.push(s)
      else if (s.length > 0 && s[0].nodeType)
        for (n = 0; n < s.length; n += 1) r.push(s[n])
    return new i(r)
  }
  function a(e) {
    for (var t = [], i = 0; i < e.length; i += 1)
      !t.includes(e[i]) && t.push(e[i])
    return t
  }
  ;(s.fn = i.prototype), (s.Class = i), (s.Dom7 = i)
  const r = {
    addClass(e) {
      if (void 0 === e) return this
      for (let t = e.split(' '), i = 0; i < t.length; i += 1)
        for (let s = 0; s < this.length; s += 1)
          void 0 !== this[s] &&
            void 0 !== this[s].classList &&
            this[s].classList.add(t[i])
      return this
    },
    removeClass(e) {
      for (let t = e.split(' '), i = 0; i < t.length; i += 1)
        for (let s = 0; s < this.length; s += 1)
          void 0 !== this[s] &&
            void 0 !== this[s].classList &&
            this[s].classList.remove(t[i])
      return this
    },
    hasClass(e) {
      return !!this[0] && this[0].classList.contains(e)
    },
    toggleClass(e) {
      for (let t = e.split(' '), i = 0; i < t.length; i += 1)
        for (let s = 0; s < this.length; s += 1)
          void 0 !== this[s] &&
            void 0 !== this[s].classList &&
            this[s].classList.toggle(t[i])
      return this
    },
    attr(e, t) {
      const i = arguments
      if (arguments.length === 1 && typeof e === 'string')
        return this[0] ? this[0].getAttribute(e) : void 0
      for (let s = 0; s < this.length; s += 1)
        if (i.length === 2) this[s].setAttribute(e, t)
        else
          for (const a in e) (this[s][a] = e[a]), this[s].setAttribute(a, e[a])
      return this
    },
    removeAttr(e) {
      for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e)
      return this
    },
    data(e, t) {
      let i
      if (void 0 !== t) {
        for (let s = 0; s < this.length; s += 1)
          (i = this[s]).dom7ElementDataStorage ||
            (i.dom7ElementDataStorage = {}),
            (i.dom7ElementDataStorage[e] = t)
        return this
      }
      if ((i = this[0])) {
        if (i.dom7ElementDataStorage && e in i.dom7ElementDataStorage)
          return i.dom7ElementDataStorage[e]
        const a = i.getAttribute('data-' + e)
        return a || void 0
      }
    },
    transform(e) {
      for (let t = 0; t < this.length; t += 1) {
        const i = this[t].style
        ;(i.webkitTransform = e), (i.transform = e)
      }
      return this
    },
    transition(e) {
      typeof e !== 'string' && (e += 'ms')
      for (let t = 0; t < this.length; t += 1) {
        const i = this[t].style
        ;(i.webkitTransitionDuration = e), (i.transitionDuration = e)
      }
      return this
    },
    on() {
      for (var e, t = [], i = arguments.length; i--; ) t[i] = arguments[i]
      let a = t[0]
      let r = t[1]
      let n = t[2]
      let o = t[3]
      function l(e) {
        const t = e.target
        if (t) {
          const i = e.target.dom7EventData || []
          if ((!i.includes(e) && i.unshift(e), s(t).is(r))) n.apply(t, i)
          else
            for (let a = s(t).parents(), o = 0; o < a.length; o += 1)
              s(a[o]).is(r) && n.apply(a[o], i)
        }
      }
      function d(e) {
        const t = (e && e.target && e.target.dom7EventData) || []
        !t.includes(e) && t.unshift(e), n.apply(this, t)
      }
      typeof t[1] === 'function' &&
        ((a = (e = t)[0]), (n = e[1]), (o = e[2]), (r = void 0)),
        o || (o = !1)
      for (var h, p = a.split(' '), c = 0; c < this.length; c += 1) {
        const u = this[c]
        if (r)
          for (h = 0; h < p.length; h += 1) {
            const v = p[h]
            u.dom7LiveListeners || (u.dom7LiveListeners = {}),
              u.dom7LiveListeners[v] || (u.dom7LiveListeners[v] = []),
              u.dom7LiveListeners[v].push({ listener: n, proxyListener: l }),
              u.addEventListener(v, l, o)
          }
        else
          for (h = 0; h < p.length; h += 1) {
            const f = p[h]
            u.dom7Listeners || (u.dom7Listeners = {}),
              u.dom7Listeners[f] || (u.dom7Listeners[f] = []),
              u.dom7Listeners[f].push({ listener: n, proxyListener: d }),
              u.addEventListener(f, d, o)
          }
      }
      return this
    },
    off() {
      for (var e, t = [], i = arguments.length; i--; ) t[i] = arguments[i]
      let s = t[0]
      let a = t[1]
      let r = t[2]
      let n = t[3]
      typeof t[1] === 'function' &&
        ((s = (e = t)[0]), (r = e[1]), (n = e[2]), (a = void 0)),
        n || (n = !1)
      for (let o = s.split(' '), l = 0; l < o.length; l += 1)
        for (let d = o[l], h = 0; h < this.length; h += 1) {
          const p = this[h]
          let c = void 0
          if (
            (!a && p.dom7Listeners
              ? (c = p.dom7Listeners[d])
              : a && p.dom7LiveListeners && (c = p.dom7LiveListeners[d]),
            c && c.length)
          )
            for (let u = c.length - 1; u >= 0; u -= 1) {
              const v = c[u]
              r && v.listener === r
                ? (p.removeEventListener(d, v.proxyListener, n), c.splice(u, 1))
                : r &&
                  v.listener &&
                  v.listener.dom7proxy &&
                  v.listener.dom7proxy === r
                ? (p.removeEventListener(d, v.proxyListener, n), c.splice(u, 1))
                : r ||
                  (p.removeEventListener(d, v.proxyListener, n), c.splice(u, 1))
            }
        }
      return this
    },
    trigger() {
      for (var i = [], s = arguments.length; s--; ) i[s] = arguments[s]
      for (let a = i[0].split(' '), r = i[1], n = 0; n < a.length; n += 1)
        for (let o = a[n], l = 0; l < this.length; l += 1) {
          const d = this[l]
          let h = void 0
          try {
            h = new t.CustomEvent(o, { detail: r, bubbles: !0, cancelable: !0 })
          } catch (t) {
            ;(h = e.createEvent('Event')).initEvent(o, !0, !0), (h.detail = r)
          }
          ;(d.dom7EventData = i.filter(function (e, t) {
            return t > 0
          })),
            d.dispatchEvent(h),
            (d.dom7EventData = []),
            delete d.dom7EventData
        }
      return this
    },
    transitionEnd(e) {
      let t
      const i = ['webkitTransitionEnd', 'transitionend']
      const s = this
      function a(r) {
        if (r.target === this)
          for (e.call(this, r), t = 0; t < i.length; t += 1) s.off(i[t], a)
      }
      if (e) for (t = 0; t < i.length; t += 1) s.on(i[t], a)
      return this
    },
    outerWidth(e) {
      if (this.length > 0) {
        if (e) {
          const t = this.styles()
          return (
            this[0].offsetWidth +
            parseFloat(t.getPropertyValue('margin-right')) +
            parseFloat(t.getPropertyValue('margin-left'))
          )
        }
        return this[0].offsetWidth
      }
      return null
    },
    outerHeight(e) {
      if (this.length > 0) {
        if (e) {
          const t = this.styles()
          return (
            this[0].offsetHeight +
            parseFloat(t.getPropertyValue('margin-top')) +
            parseFloat(t.getPropertyValue('margin-bottom'))
          )
        }
        return this[0].offsetHeight
      }
      return null
    },
    offset() {
      if (this.length > 0) {
        const i = this[0]
        const s = i.getBoundingClientRect()
        const a = e.body
        const r = i.clientTop || a.clientTop || 0
        const n = i.clientLeft || a.clientLeft || 0
        const o = i === t ? t.scrollY : i.scrollTop
        const l = i === t ? t.scrollX : i.scrollLeft
        return { top: s.top + o - r, left: s.left + l - n }
      }
      return null
    },
    css(e, i) {
      let s
      if (arguments.length === 1) {
        if (typeof e !== 'string') {
          for (s = 0; s < this.length; s += 1)
            for (const a in e) this[s].style[a] = e[a]
          return this
        }
        if (this[0])
          return t.getComputedStyle(this[0], null).getPropertyValue(e)
      }
      if (arguments.length === 2 && typeof e === 'string') {
        for (s = 0; s < this.length; s += 1) this[s].style[e] = i
        return this
      }
      return this
    },
    each(e) {
      if (!e) return this
      for (let t = 0; t < this.length; t += 1)
        if (!1 === e.call(this[t], t, this[t])) return this
      return this
    },
    html(e) {
      if (void 0 === e) return this[0] ? this[0].innerHTML : void 0
      for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e
      return this
    },
    text(e) {
      if (void 0 === e) return this[0] ? this[0].textContent.trim() : null
      for (let t = 0; t < this.length; t += 1) this[t].textContent = e
      return this
    },
    is(a) {
      let r
      let n
      const o = this[0]
      if (!o || void 0 === a) return !1
      if (typeof a === 'string') {
        if (o.matches) return o.matches(a)
        if (o.webkitMatchesSelector) return o.webkitMatchesSelector(a)
        if (o.msMatchesSelector) return o.msMatchesSelector(a)
        for (r = s(a), n = 0; n < r.length; n += 1) if (r[n] === o) return !0
        return !1
      }
      if (a === e) return o === e
      if (a === t) return o === t
      if (a.nodeType || a instanceof i) {
        for (r = a.nodeType ? [a] : a, n = 0; n < r.length; n += 1)
          if (r[n] === o) return !0
        return !1
      }
      return !1
    },
    index() {
      let e
      let t = this[0]
      if (t) {
        for (e = 0; (t = t.previousSibling) !== null; )
          t.nodeType === 1 && (e += 1)
        return e
      }
    },
    eq(e) {
      if (void 0 === e) return this
      let t
      const s = this.length
      return new i(
        e > s - 1 ? [] : e < 0 ? ((t = s + e) < 0 ? [] : [this[t]]) : [this[e]]
      )
    },
    append() {
      for (var t, s = [], a = arguments.length; a--; ) s[a] = arguments[a]
      for (let r = 0; r < s.length; r += 1) {
        t = s[r]
        for (let n = 0; n < this.length; n += 1)
          if (typeof t === 'string') {
            const o = e.createElement('div')
            for (o.innerHTML = t; o.firstChild; )
              this[n].appendChild(o.firstChild)
          } else if (t instanceof i)
            for (let l = 0; l < t.length; l += 1) this[n].appendChild(t[l])
          else this[n].appendChild(t)
      }
      return this
    },
    prepend(t) {
      let s, a
      for (s = 0; s < this.length; s += 1)
        if (typeof t === 'string') {
          const r = e.createElement('div')
          for (r.innerHTML = t, a = r.childNodes.length - 1; a >= 0; a -= 1)
            this[s].insertBefore(r.childNodes[a], this[s].childNodes[0])
        } else if (t instanceof i)
          for (a = 0; a < t.length; a += 1)
            this[s].insertBefore(t[a], this[s].childNodes[0])
        else this[s].insertBefore(t, this[s].childNodes[0])
      return this
    },
    next(e) {
      return this.length > 0
        ? e
          ? this[0].nextElementSibling && s(this[0].nextElementSibling).is(e)
            ? new i([this[0].nextElementSibling])
            : new i([])
          : this[0].nextElementSibling
          ? new i([this[0].nextElementSibling])
          : new i([])
        : new i([])
    },
    nextAll(e) {
      const t = []
      let a = this[0]
      if (!a) return new i([])
      for (; a.nextElementSibling; ) {
        const r = a.nextElementSibling
        e ? s(r).is(e) && t.push(r) : t.push(r), (a = r)
      }
      return new i(t)
    },
    prev(e) {
      if (this.length > 0) {
        const t = this[0]
        return e
          ? t.previousElementSibling && s(t.previousElementSibling).is(e)
            ? new i([t.previousElementSibling])
            : new i([])
          : t.previousElementSibling
          ? new i([t.previousElementSibling])
          : new i([])
      }
      return new i([])
    },
    prevAll(e) {
      const t = []
      let a = this[0]
      if (!a) return new i([])
      for (; a.previousElementSibling; ) {
        const r = a.previousElementSibling
        e ? s(r).is(e) && t.push(r) : t.push(r), (a = r)
      }
      return new i(t)
    },
    parent(e) {
      for (var t = [], i = 0; i < this.length; i += 1)
        this[i].parentNode !== null &&
          (e
            ? s(this[i].parentNode).is(e) && t.push(this[i].parentNode)
            : t.push(this[i].parentNode))
      return s(a(t))
    },
    parents(e) {
      for (var t = [], i = 0; i < this.length; i += 1)
        for (let r = this[i].parentNode; r; )
          e ? s(r).is(e) && t.push(r) : t.push(r), (r = r.parentNode)
      return s(a(t))
    },
    closest(e) {
      let t = this
      return void 0 === e ? new i([]) : (t.is(e) || (t = t.parents(e).eq(0)), t)
    },
    find(e) {
      for (var t = [], s = 0; s < this.length; s += 1)
        for (let a = this[s].querySelectorAll(e), r = 0; r < a.length; r += 1)
          t.push(a[r])
      return new i(t)
    },
    children(e) {
      for (var t = [], r = 0; r < this.length; r += 1)
        for (let n = this[r].childNodes, o = 0; o < n.length; o += 1)
          e
            ? n[o].nodeType === 1 && s(n[o]).is(e) && t.push(n[o])
            : n[o].nodeType === 1 && t.push(n[o])
      return new i(a(t))
    },
    filter(e) {
      for (var t = [], s = 0; s < this.length; s += 1)
        e.call(this[s], s, this[s]) && t.push(this[s])
      return new i(t)
    },
    remove() {
      for (let e = 0; e < this.length; e += 1)
        this[e].parentNode && this[e].parentNode.removeChild(this[e])
      return this
    },
    add() {
      for (var e = [], t = arguments.length; t--; ) e[t] = arguments[t]
      let i, a
      for (i = 0; i < e.length; i += 1) {
        const r = s(e[i])
        for (a = 0; a < r.length; a += 1)
          (this[this.length] = r[a]), (this.length += 1)
      }
      return this
    },
    styles() {
      return this[0] ? t.getComputedStyle(this[0], null) : {}
    },
  }
  Object.keys(r).forEach(function (e) {
    s.fn[e] = s.fn[e] || r[e]
  })
  var n = {
    deleteProps(e) {
      const t = e
      Object.keys(t).forEach(function (e) {
        try {
          t[e] = null
        } catch (e) {}
        try {
          delete t[e]
        } catch (e) {}
      })
    },
    nextTick(e, t) {
      return void 0 === t && (t = 0), setTimeout(e, t)
    },
    now() {
      return Date.now()
    },
    getTranslate(e, i) {
      let s, a, r
      void 0 === i && (i = 'x')
      const n = t.getComputedStyle(e, null)
      return (
        t.WebKitCSSMatrix
          ? ((a = n.transform || n.webkitTransform).split(',').length > 6 &&
              (a = a
                .split(', ')
                .map(function (e) {
                  return e.replace(',', '.')
                })
                .join(', ')),
            (r = new t.WebKitCSSMatrix(a === 'none' ? '' : a)))
          : (s = (r =
              n.MozTransform ||
              n.OTransform ||
              n.MsTransform ||
              n.msTransform ||
              n.transform ||
              n
                .getPropertyValue('transform')
                .replace('translate(', 'matrix(1, 0, 0, 1,'))
              .toString()
              .split(',')),
        i === 'x' &&
          (a = t.WebKitCSSMatrix
            ? r.m41
            : s.length === 16
            ? parseFloat(s[12])
            : parseFloat(s[4])),
        i === 'y' &&
          (a = t.WebKitCSSMatrix
            ? r.m42
            : s.length === 16
            ? parseFloat(s[13])
            : parseFloat(s[5])),
        a || 0
      )
    },
    parseUrlQuery(e) {
      let i
      let s
      let a
      let r
      const n = {}
      let o = e || t.location.href
      if (typeof o === 'string' && o.length)
        for (
          r = (s = (o = o.includes('?') ? o.replace(/\S*\?/, '') : '')
            .split('&')
            .filter(function (e) {
              return e !== ''
            })).length,
            i = 0;
          i < r;
          i += 1
        )
          (a = s[i].replace(/#\S+/g, '').split('=')),
            (n[decodeURIComponent(a[0])] =
              void 0 === a[1] ? void 0 : decodeURIComponent(a[1]) || '')
      return n
    },
    isObject(e) {
      return (
        typeof e === 'object' &&
        e !== null &&
        e.constructor &&
        e.constructor === Object
      )
    },
    extend() {
      for (var e = [], t = arguments.length; t--; ) e[t] = arguments[t]
      for (var i = Object(e[0]), s = 1; s < e.length; s += 1) {
        const a = e[s]
        if (a != null)
          for (
            let r = Object.keys(Object(a)), o = 0, l = r.length;
            o < l;
            o += 1
          ) {
            const d = r[o]
            const h = Object.getOwnPropertyDescriptor(a, d)
            void 0 !== h &&
              h.enumerable &&
              (n.isObject(i[d]) && n.isObject(a[d])
                ? n.extend(i[d], a[d])
                : !n.isObject(i[d]) && n.isObject(a[d])
                ? ((i[d] = {}), n.extend(i[d], a[d]))
                : (i[d] = a[d]))
          }
      }
      return i
    },
  }
  const o = {
    touch:
      (t.Modernizr && !0 === t.Modernizr.touch) ||
      !!(
        t.navigator.maxTouchPoints > 0 ||
        'ontouchstart' in t ||
        (t.DocumentTouch && e instanceof t.DocumentTouch)
      ),
    pointerEvents:
      !!t.PointerEvent &&
      'maxTouchPoints' in t.navigator &&
      t.navigator.maxTouchPoints > 0,
    observer: 'MutationObserver' in t || 'WebkitMutationObserver' in t,
    passiveListener: (function () {
      let e = !1
      try {
        const i = Object.defineProperty({}, 'passive', {
          get() {
            e = !0
          },
        })
        t.addEventListener('testPassiveListener', null, i)
      } catch (e) {}
      return e
    })(),
    gestures: 'ongesturestart' in t,
  }
  const l = function (e) {
    void 0 === e && (e = {})
    const t = this
    ;(t.params = e),
      (t.eventsListeners = {}),
      t.params &&
        t.params.on &&
        Object.keys(t.params.on).forEach(function (e) {
          t.on(e, t.params.on[e])
        })
  }
  const d = { components: { configurable: !0 } }
  ;(l.prototype.on = function (e, t, i) {
    const s = this
    if (typeof t !== 'function') return s
    const a = i ? 'unshift' : 'push'
    return (
      e.split(' ').forEach(function (e) {
        s.eventsListeners[e] || (s.eventsListeners[e] = []),
          s.eventsListeners[e][a](t)
      }),
      s
    )
  }),
    (l.prototype.once = function (e, t, i) {
      const s = this
      if (typeof t !== 'function') return s
      function a() {
        for (var i = [], r = arguments.length; r--; ) i[r] = arguments[r]
        t.apply(s, i), s.off(e, a), a.f7proxy && delete a.f7proxy
      }
      return (a.f7proxy = t), s.on(e, a, i)
    }),
    (l.prototype.off = function (e, t) {
      const i = this
      return i.eventsListeners
        ? (e.split(' ').forEach(function (e) {
            void 0 === t
              ? (i.eventsListeners[e] = [])
              : i.eventsListeners[e] &&
                i.eventsListeners[e].length &&
                i.eventsListeners[e].forEach(function (s, a) {
                  ;(s === t || (s.f7proxy && s.f7proxy === t)) &&
                    i.eventsListeners[e].splice(a, 1)
                })
          }),
          i)
        : i
    }),
    (l.prototype.emit = function () {
      for (var e = [], t = arguments.length; t--; ) e[t] = arguments[t]
      let i
      let s
      let a
      const r = this
      if (!r.eventsListeners) return r
      typeof e[0] === 'string' || Array.isArray(e[0])
        ? ((i = e[0]), (s = e.slice(1, e.length)), (a = r))
        : ((i = e[0].events), (s = e[0].data), (a = e[0].context || r))
      const n = Array.isArray(i) ? i : i.split(' ')
      return (
        n.forEach(function (e) {
          if (r.eventsListeners && r.eventsListeners[e]) {
            const t = []
            r.eventsListeners[e].forEach(function (e) {
              t.push(e)
            }),
              t.forEach(function (e) {
                e.apply(a, s)
              })
          }
        }),
        r
      )
    }),
    (l.prototype.useModulesParams = function (e) {
      const t = this
      t.modules &&
        Object.keys(t.modules).forEach(function (i) {
          const s = t.modules[i]
          s.params && n.extend(e, s.params)
        })
    }),
    (l.prototype.useModules = function (e) {
      void 0 === e && (e = {})
      const t = this
      t.modules &&
        Object.keys(t.modules).forEach(function (i) {
          const s = t.modules[i]
          const a = e[i] || {}
          s.instance &&
            Object.keys(s.instance).forEach(function (e) {
              const i = s.instance[e]
              t[e] = typeof i === 'function' ? i.bind(t) : i
            }),
            s.on &&
              t.on &&
              Object.keys(s.on).forEach(function (e) {
                t.on(e, s.on[e])
              }),
            s.create && s.create.bind(t)(a)
        })
    }),
    (d.components.set = function (e) {
      this.use && this.use(e)
    }),
    (l.installModule = function (e) {
      for (var t = [], i = arguments.length - 1; i-- > 0; )
        t[i] = arguments[i + 1]
      const s = this
      s.prototype.modules || (s.prototype.modules = {})
      const a =
        e.name || Object.keys(s.prototype.modules).length + '_' + n.now()
      return (
        (s.prototype.modules[a] = e),
        e.proto &&
          Object.keys(e.proto).forEach(function (t) {
            s.prototype[t] = e.proto[t]
          }),
        e.static &&
          Object.keys(e.static).forEach(function (t) {
            s[t] = e.static[t]
          }),
        e.install && e.install.apply(s, t),
        s
      )
    }),
    (l.use = function (e) {
      for (var t = [], i = arguments.length - 1; i-- > 0; )
        t[i] = arguments[i + 1]
      const s = this
      return Array.isArray(e)
        ? (e.forEach(function (e) {
            return s.installModule(e)
          }),
          s)
        : s.installModule.apply(s, [e].concat(t))
    }),
    Object.defineProperties(l, d)
  const h = {
    updateSize() {
      let e
      let t
      const i = this.$el
      ;(e =
        void 0 !== this.params.width ? this.params.width : i[0].clientWidth),
        (t =
          void 0 !== this.params.height
            ? this.params.height
            : i[0].clientHeight),
        (e === 0 && this.isHorizontal()) ||
          (t === 0 && this.isVertical()) ||
          ((e =
            e -
            parseInt(i.css('padding-left'), 10) -
            parseInt(i.css('padding-right'), 10)),
          (t =
            t -
            parseInt(i.css('padding-top'), 10) -
            parseInt(i.css('padding-bottom'), 10)),
          n.extend(this, {
            width: e,
            height: t,
            size: this.isHorizontal() ? e : t,
          }))
    },
    updateSlides() {
      const e = this.params
      const i = this.$wrapperEl
      const s = this.size
      const a = this.rtlTranslate
      const r = this.wrongRTL
      const o = this.virtual && e.virtual.enabled
      const l = o ? this.virtual.slides.length : this.slides.length
      const d = i.children('.' + this.params.slideClass)
      const h = o ? this.virtual.slides.length : d.length
      let p = []
      const c = []
      const u = []
      function v(t) {
        return !e.cssMode || t !== d.length - 1
      }
      let f = e.slidesOffsetBefore
      typeof f === 'function' && (f = e.slidesOffsetBefore.call(this))
      let m = e.slidesOffsetAfter
      typeof m === 'function' && (m = e.slidesOffsetAfter.call(this))
      const g = this.snapGrid.length
      const b = this.snapGrid.length
      let w = e.spaceBetween
      let y = -f
      let x = 0
      let T = 0
      if (void 0 !== s) {
        let E, C
        typeof w === 'string' &&
          w.includes('%') &&
          (w = (parseFloat(w.replace('%', '')) / 100) * s),
          (this.virtualSize = -w),
          a
            ? d.css({ marginLeft: '', marginTop: '' })
            : d.css({ marginRight: '', marginBottom: '' }),
          e.slidesPerColumn > 1 &&
            ((E =
              Math.floor(h / e.slidesPerColumn) ===
              h / this.params.slidesPerColumn
                ? h
                : Math.ceil(h / e.slidesPerColumn) * e.slidesPerColumn),
            e.slidesPerView !== 'auto' &&
              e.slidesPerColumnFill === 'row' &&
              (E = Math.max(E, e.slidesPerView * e.slidesPerColumn)))
        for (
          var S,
            M = e.slidesPerColumn,
            P = E / M,
            z = Math.floor(h / e.slidesPerColumn),
            k = 0;
          k < h;
          k += 1
        ) {
          C = 0
          const $ = d.eq(k)
          if (e.slidesPerColumn > 1) {
            let L = void 0
            let I = void 0
            let D = void 0
            if (e.slidesPerColumnFill === 'row' && e.slidesPerGroup > 1) {
              const O = Math.floor(k / (e.slidesPerGroup * e.slidesPerColumn))
              const A = k - e.slidesPerColumn * e.slidesPerGroup * O
              const G =
                O === 0
                  ? e.slidesPerGroup
                  : Math.min(
                      Math.ceil((h - O * M * e.slidesPerGroup) / M),
                      e.slidesPerGroup
                    )
              ;(L =
                (I = A - (D = Math.floor(A / G)) * G + O * e.slidesPerGroup) +
                (D * E) / M),
                $.css({
                  '-webkit-box-ordinal-group': L,
                  '-moz-box-ordinal-group': L,
                  '-ms-flex-order': L,
                  '-webkit-order': L,
                  order: L,
                })
            } else
              e.slidesPerColumnFill === 'column'
                ? ((D = k - (I = Math.floor(k / M)) * M),
                  (I > z || (I === z && D === M - 1)) &&
                    (D += 1) >= M &&
                    ((D = 0), (I += 1)))
                : (I = k - (D = Math.floor(k / P)) * P)
            $.css(
              'margin-' + (this.isHorizontal() ? 'top' : 'left'),
              D !== 0 && e.spaceBetween && e.spaceBetween + 'px'
            )
          }
          if ($.css('display') !== 'none') {
            if (e.slidesPerView === 'auto') {
              const B = t.getComputedStyle($[0], null)
              const H = $[0].style.transform
              const N = $[0].style.webkitTransform
              if (
                (H && ($[0].style.transform = 'none'),
                N && ($[0].style.webkitTransform = 'none'),
                e.roundLengths)
              )
                C = this.isHorizontal() ? $.outerWidth(!0) : $.outerHeight(!0)
              else if (this.isHorizontal()) {
                const X = parseFloat(B.getPropertyValue('width'))
                const V = parseFloat(B.getPropertyValue('padding-left'))
                const Y = parseFloat(B.getPropertyValue('padding-right'))
                const F = parseFloat(B.getPropertyValue('margin-left'))
                const W = parseFloat(B.getPropertyValue('margin-right'))
                const R = B.getPropertyValue('box-sizing')
                C = R && R === 'border-box' ? X + F + W : X + V + Y + F + W
              } else {
                const q = parseFloat(B.getPropertyValue('height'))
                const j = parseFloat(B.getPropertyValue('padding-top'))
                const K = parseFloat(B.getPropertyValue('padding-bottom'))
                const U = parseFloat(B.getPropertyValue('margin-top'))
                const _ = parseFloat(B.getPropertyValue('margin-bottom'))
                const Z = B.getPropertyValue('box-sizing')
                C = Z && Z === 'border-box' ? q + U + _ : q + j + K + U + _
              }
              H && ($[0].style.transform = H),
                N && ($[0].style.webkitTransform = N),
                e.roundLengths && (C = Math.floor(C))
            } else
              (C = (s - (e.slidesPerView - 1) * w) / e.slidesPerView),
                e.roundLengths && (C = Math.floor(C)),
                d[k] &&
                  (this.isHorizontal()
                    ? (d[k].style.width = C + 'px')
                    : (d[k].style.height = C + 'px'))
            d[k] && (d[k].swiperSlideSize = C),
              u.push(C),
              e.centeredSlides
                ? ((y = y + C / 2 + x / 2 + w),
                  x === 0 && k !== 0 && (y = y - s / 2 - w),
                  k === 0 && (y = y - s / 2 - w),
                  Math.abs(y) < 0.001 && (y = 0),
                  e.roundLengths && (y = Math.floor(y)),
                  T % e.slidesPerGroup == 0 && p.push(y),
                  c.push(y))
                : (e.roundLengths && (y = Math.floor(y)),
                  T % e.slidesPerGroup == 0 && p.push(y),
                  c.push(y),
                  (y = y + C + w)),
              (this.virtualSize += C + w),
              (x = C),
              (T += 1)
          }
        }
        if (
          ((this.virtualSize = Math.max(this.virtualSize, s) + m),
          a &&
            r &&
            (e.effect === 'slide' || e.effect === 'coverflow') &&
            i.css({ width: this.virtualSize + e.spaceBetween + 'px' }),
          e.setWrapperSize &&
            (this.isHorizontal()
              ? i.css({ width: this.virtualSize + e.spaceBetween + 'px' })
              : i.css({ height: this.virtualSize + e.spaceBetween + 'px' })),
          e.slidesPerColumn > 1 &&
            ((this.virtualSize = (C + e.spaceBetween) * E),
            (this.virtualSize =
              Math.ceil(this.virtualSize / e.slidesPerColumn) - e.spaceBetween),
            this.isHorizontal()
              ? i.css({ width: this.virtualSize + e.spaceBetween + 'px' })
              : i.css({ height: this.virtualSize + e.spaceBetween + 'px' }),
            e.centeredSlides))
        ) {
          S = []
          for (let Q = 0; Q < p.length; Q += 1) {
            let J = p[Q]
            e.roundLengths && (J = Math.floor(J)),
              p[Q] < this.virtualSize + p[0] && S.push(J)
          }
          p = S
        }
        if (!e.centeredSlides) {
          S = []
          for (let ee = 0; ee < p.length; ee += 1) {
            let te = p[ee]
            e.roundLengths && (te = Math.floor(te)),
              p[ee] <= this.virtualSize - s && S.push(te)
          }
          ;(p = S),
            Math.floor(this.virtualSize - s) - Math.floor(p[p.length - 1]) >
              1 && p.push(this.virtualSize - s)
        }
        if (
          (p.length === 0 && (p = [0]),
          e.spaceBetween !== 0 &&
            (this.isHorizontal()
              ? a
                ? d.filter(v).css({ marginLeft: w + 'px' })
                : d.filter(v).css({ marginRight: w + 'px' })
              : d.filter(v).css({ marginBottom: w + 'px' })),
          e.centeredSlides && e.centeredSlidesBounds)
        ) {
          let ie = 0
          u.forEach(function (t) {
            ie += t + (e.spaceBetween ? e.spaceBetween : 0)
          })
          const se = (ie -= e.spaceBetween) - s
          p = p.map(function (e) {
            return e < 0 ? -f : e > se ? se + m : e
          })
        }
        if (e.centerInsufficientSlides) {
          let ae = 0
          if (
            (u.forEach(function (t) {
              ae += t + (e.spaceBetween ? e.spaceBetween : 0)
            }),
            (ae -= e.spaceBetween) < s)
          ) {
            const re = (s - ae) / 2
            p.forEach(function (e, t) {
              p[t] = e - re
            }),
              c.forEach(function (e, t) {
                c[t] = e + re
              })
          }
        }
        n.extend(this, {
          slides: d,
          snapGrid: p,
          slidesGrid: c,
          slidesSizesGrid: u,
        }),
          h !== l && this.emit('slidesLengthChange'),
          p.length !== g &&
            (this.params.watchOverflow && this.checkOverflow(),
            this.emit('snapGridLengthChange')),
          c.length !== b && this.emit('slidesGridLengthChange'),
          (e.watchSlidesProgress || e.watchSlidesVisibility) &&
            this.updateSlidesOffset()
      }
    },
    updateAutoHeight(e) {
      let t
      const i = []
      let s = 0
      if (
        (typeof e === 'number'
          ? this.setTransition(e)
          : !0 === e && this.setTransition(this.params.speed),
        this.params.slidesPerView !== 'auto' && this.params.slidesPerView > 1)
      )
        for (t = 0; t < Math.ceil(this.params.slidesPerView); t += 1) {
          const a = this.activeIndex + t
          if (a > this.slides.length) break
          i.push(this.slides.eq(a)[0])
        }
      else i.push(this.slides.eq(this.activeIndex)[0])
      for (t = 0; t < i.length; t += 1)
        if (void 0 !== i[t]) {
          const r = i[t].offsetHeight
          s = r > s ? r : s
        }
      s && this.$wrapperEl.css('height', s + 'px')
    },
    updateSlidesOffset() {
      for (let e = this.slides, t = 0; t < e.length; t += 1)
        e[t].swiperSlideOffset = this.isHorizontal()
          ? e[t].offsetLeft
          : e[t].offsetTop
    },
    updateSlidesProgress(e) {
      void 0 === e && (e = (this && this.translate) || 0)
      const t = this.params
      const i = this.slides
      const a = this.rtlTranslate
      if (i.length !== 0) {
        void 0 === i[0].swiperSlideOffset && this.updateSlidesOffset()
        let r = -e
        a && (r = e),
          i.removeClass(t.slideVisibleClass),
          (this.visibleSlidesIndexes = []),
          (this.visibleSlides = [])
        for (let n = 0; n < i.length; n += 1) {
          const o = i[n]
          const l =
            (r +
              (t.centeredSlides ? this.minTranslate() : 0) -
              o.swiperSlideOffset) /
            (o.swiperSlideSize + t.spaceBetween)
          if (t.watchSlidesVisibility) {
            const d = -(r - o.swiperSlideOffset)
            const h = d + this.slidesSizesGrid[n]
            ;((d >= 0 && d < this.size - 1) ||
              (h > 1 && h <= this.size) ||
              (d <= 0 && h >= this.size)) &&
              (this.visibleSlides.push(o),
              this.visibleSlidesIndexes.push(n),
              i.eq(n).addClass(t.slideVisibleClass))
          }
          o.progress = a ? -l : l
        }
        this.visibleSlides = s(this.visibleSlides)
      }
    },
    updateProgress(e) {
      if (void 0 === e) {
        const t = this.rtlTranslate ? -1 : 1
        e = (this && this.translate && this.translate * t) || 0
      }
      const i = this.params
      const s = this.maxTranslate() - this.minTranslate()
      let a = this.progress
      let r = this.isBeginning
      let o = this.isEnd
      const l = r
      const d = o
      s === 0
        ? ((a = 0), (r = !0), (o = !0))
        : ((r = (a = (e - this.minTranslate()) / s) <= 0), (o = a >= 1)),
        n.extend(this, { progress: a, isBeginning: r, isEnd: o }),
        (i.watchSlidesProgress || i.watchSlidesVisibility) &&
          this.updateSlidesProgress(e),
        r && !l && this.emit('reachBeginning toEdge'),
        o && !d && this.emit('reachEnd toEdge'),
        ((l && !r) || (d && !o)) && this.emit('fromEdge'),
        this.emit('progress', a)
    },
    updateSlidesClasses() {
      let e
      const t = this.slides
      const i = this.params
      const s = this.$wrapperEl
      const a = this.activeIndex
      const r = this.realIndex
      const n = this.virtual && i.virtual.enabled
      t.removeClass(
        i.slideActiveClass +
          ' ' +
          i.slideNextClass +
          ' ' +
          i.slidePrevClass +
          ' ' +
          i.slideDuplicateActiveClass +
          ' ' +
          i.slideDuplicateNextClass +
          ' ' +
          i.slideDuplicatePrevClass
      ),
        (e = n
          ? this.$wrapperEl.find(
              '.' + i.slideClass + '[data-swiper-slide-index="' + a + '"]'
            )
          : t.eq(a)).addClass(i.slideActiveClass),
        i.loop &&
          (e.hasClass(i.slideDuplicateClass)
            ? s
                .children(
                  '.' +
                    i.slideClass +
                    ':not(.' +
                    i.slideDuplicateClass +
                    ')[data-swiper-slide-index="' +
                    r +
                    '"]'
                )
                .addClass(i.slideDuplicateActiveClass)
            : s
                .children(
                  '.' +
                    i.slideClass +
                    '.' +
                    i.slideDuplicateClass +
                    '[data-swiper-slide-index="' +
                    r +
                    '"]'
                )
                .addClass(i.slideDuplicateActiveClass))
      let o = e
        .nextAll('.' + i.slideClass)
        .eq(0)
        .addClass(i.slideNextClass)
      i.loop && o.length === 0 && (o = t.eq(0)).addClass(i.slideNextClass)
      let l = e
        .prevAll('.' + i.slideClass)
        .eq(0)
        .addClass(i.slidePrevClass)
      i.loop && l.length === 0 && (l = t.eq(-1)).addClass(i.slidePrevClass),
        i.loop &&
          (o.hasClass(i.slideDuplicateClass)
            ? s
                .children(
                  '.' +
                    i.slideClass +
                    ':not(.' +
                    i.slideDuplicateClass +
                    ')[data-swiper-slide-index="' +
                    o.attr('data-swiper-slide-index') +
                    '"]'
                )
                .addClass(i.slideDuplicateNextClass)
            : s
                .children(
                  '.' +
                    i.slideClass +
                    '.' +
                    i.slideDuplicateClass +
                    '[data-swiper-slide-index="' +
                    o.attr('data-swiper-slide-index') +
                    '"]'
                )
                .addClass(i.slideDuplicateNextClass),
          l.hasClass(i.slideDuplicateClass)
            ? s
                .children(
                  '.' +
                    i.slideClass +
                    ':not(.' +
                    i.slideDuplicateClass +
                    ')[data-swiper-slide-index="' +
                    l.attr('data-swiper-slide-index') +
                    '"]'
                )
                .addClass(i.slideDuplicatePrevClass)
            : s
                .children(
                  '.' +
                    i.slideClass +
                    '.' +
                    i.slideDuplicateClass +
                    '[data-swiper-slide-index="' +
                    l.attr('data-swiper-slide-index') +
                    '"]'
                )
                .addClass(i.slideDuplicatePrevClass))
    },
    updateActiveIndex(e) {
      let t
      const i = this.rtlTranslate ? this.translate : -this.translate
      const s = this.slidesGrid
      const a = this.snapGrid
      const r = this.params
      const o = this.activeIndex
      const l = this.realIndex
      const d = this.snapIndex
      let h = e
      if (void 0 === h) {
        for (let p = 0; p < s.length; p += 1)
          void 0 !== s[p + 1]
            ? i >= s[p] && i < s[p + 1] - (s[p + 1] - s[p]) / 2
              ? (h = p)
              : i >= s[p] && i < s[p + 1] && (h = p + 1)
            : i >= s[p] && (h = p)
        r.normalizeSlideIndex && (h < 0 || void 0 === h) && (h = 0)
      }
      if (
        ((t = a.includes(i)
          ? a.indexOf(i)
          : Math.floor(h / r.slidesPerGroup)) >= a.length && (t = a.length - 1),
        h !== o)
      ) {
        const c = parseInt(
          this.slides.eq(h).attr('data-swiper-slide-index') || h,
          10
        )
        n.extend(this, {
          snapIndex: t,
          realIndex: c,
          previousIndex: o,
          activeIndex: h,
        }),
          this.emit('activeIndexChange'),
          this.emit('snapIndexChange'),
          l !== c && this.emit('realIndexChange'),
          (this.initialized || this.runCallbacksOnInit) &&
            this.emit('slideChange')
      } else t !== d && ((this.snapIndex = t), this.emit('snapIndexChange'))
    },
    updateClickedSlide(e) {
      const t = this.params
      const i = s(e.target).closest('.' + t.slideClass)[0]
      let a = !1
      if (i)
        for (let r = 0; r < this.slides.length; r += 1)
          this.slides[r] === i && (a = !0)
      if (!i || !a)
        return (this.clickedSlide = void 0), void (this.clickedIndex = void 0)
      ;(this.clickedSlide = i),
        this.virtual && this.params.virtual.enabled
          ? (this.clickedIndex = parseInt(
              s(i).attr('data-swiper-slide-index'),
              10
            ))
          : (this.clickedIndex = s(i).index()),
        t.slideToClickedSlide &&
          void 0 !== this.clickedIndex &&
          this.clickedIndex !== this.activeIndex &&
          this.slideToClickedSlide()
    },
  }
  const p = {
    getTranslate(e) {
      void 0 === e && (e = this.isHorizontal() ? 'x' : 'y')
      const t = this.params
      const i = this.rtlTranslate
      const s = this.translate
      const a = this.$wrapperEl
      if (t.virtualTranslate) return i ? -s : s
      if (t.cssMode) return s
      let r = n.getTranslate(a[0], e)
      return i && (r = -r), r || 0
    },
    setTranslate(e, t) {
      const i = this.rtlTranslate
      const s = this.params
      const a = this.$wrapperEl
      const r = this.wrapperEl
      const n = this.progress
      let o = 0
      let l = 0
      this.isHorizontal() ? (o = i ? -e : e) : (l = e),
        s.roundLengths && ((o = Math.floor(o)), (l = Math.floor(l))),
        s.cssMode
          ? (r[this.isHorizontal() ? 'scrollLeft' : 'scrollTop'] =
              this.isHorizontal() ? -o : -l)
          : s.virtualTranslate ||
            a.transform('translate3d(' + o + 'px, ' + l + 'px, 0px)'),
        (this.previousTranslate = this.translate),
        (this.translate = this.isHorizontal() ? o : l)
      const d = this.maxTranslate() - this.minTranslate()
      ;(d === 0 ? 0 : (e - this.minTranslate()) / d) !== n &&
        this.updateProgress(e),
        this.emit('setTranslate', this.translate, t)
    },
    minTranslate() {
      return -this.snapGrid[0]
    },
    maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1]
    },
    translateTo(e, t, i, s, a) {
      let r
      void 0 === e && (e = 0),
        void 0 === t && (t = this.params.speed),
        void 0 === i && (i = !0),
        void 0 === s && (s = !0)
      const n = this
      const o = n.params
      const l = n.wrapperEl
      if (n.animating && o.preventInteractionOnTransition) return !1
      let d
      const h = n.minTranslate()
      const p = n.maxTranslate()
      if (
        ((d = s && e > h ? h : s && e < p ? p : e),
        n.updateProgress(d),
        o.cssMode)
      ) {
        const c = n.isHorizontal()
        return (
          t === 0
            ? (l[c ? 'scrollLeft' : 'scrollTop'] = -d)
            : l.scrollTo
            ? l.scrollTo(
                (((r = {})[c ? 'left' : 'top'] = -d),
                (r.behavior = 'smooth'),
                r)
              )
            : (l[c ? 'scrollLeft' : 'scrollTop'] = -d),
          !0
        )
      }
      return (
        t === 0
          ? (n.setTransition(0),
            n.setTranslate(d),
            i &&
              (n.emit('beforeTransitionStart', t, a), n.emit('transitionEnd')))
          : (n.setTransition(t),
            n.setTranslate(d),
            i &&
              (n.emit('beforeTransitionStart', t, a),
              n.emit('transitionStart')),
            n.animating ||
              ((n.animating = !0),
              n.onTranslateToWrapperTransitionEnd ||
                (n.onTranslateToWrapperTransitionEnd = function (e) {
                  n &&
                    !n.destroyed &&
                    e.target === this &&
                    (n.$wrapperEl[0].removeEventListener(
                      'transitionend',
                      n.onTranslateToWrapperTransitionEnd
                    ),
                    n.$wrapperEl[0].removeEventListener(
                      'webkitTransitionEnd',
                      n.onTranslateToWrapperTransitionEnd
                    ),
                    (n.onTranslateToWrapperTransitionEnd = null),
                    delete n.onTranslateToWrapperTransitionEnd,
                    i && n.emit('transitionEnd'))
                }),
              n.$wrapperEl[0].addEventListener(
                'transitionend',
                n.onTranslateToWrapperTransitionEnd
              ),
              n.$wrapperEl[0].addEventListener(
                'webkitTransitionEnd',
                n.onTranslateToWrapperTransitionEnd
              ))),
        !0
      )
    },
  }
  const c = {
    setTransition(e, t) {
      this.params.cssMode || this.$wrapperEl.transition(e),
        this.emit('setTransition', e, t)
    },
    transitionStart(e, t) {
      void 0 === e && (e = !0)
      const i = this.activeIndex
      const s = this.params
      const a = this.previousIndex
      if (!s.cssMode) {
        s.autoHeight && this.updateAutoHeight()
        let r = t
        if (
          (r || (r = i > a ? 'next' : i < a ? 'prev' : 'reset'),
          this.emit('transitionStart'),
          e && i !== a)
        ) {
          if (r === 'reset') return void this.emit('slideResetTransitionStart')
          this.emit('slideChangeTransitionStart'),
            r === 'next'
              ? this.emit('slideNextTransitionStart')
              : this.emit('slidePrevTransitionStart')
        }
      }
    },
    transitionEnd(e, t) {
      void 0 === e && (e = !0)
      const i = this.activeIndex
      const s = this.previousIndex
      const a = this.params
      if (((this.animating = !1), !a.cssMode)) {
        this.setTransition(0)
        let r = t
        if (
          (r || (r = i > s ? 'next' : i < s ? 'prev' : 'reset'),
          this.emit('transitionEnd'),
          e && i !== s)
        ) {
          if (r === 'reset') return void this.emit('slideResetTransitionEnd')
          this.emit('slideChangeTransitionEnd'),
            r === 'next'
              ? this.emit('slideNextTransitionEnd')
              : this.emit('slidePrevTransitionEnd')
        }
      }
    },
  }
  const u = {
    slideTo(e, t, i, s) {
      let a
      void 0 === e && (e = 0),
        void 0 === t && (t = this.params.speed),
        void 0 === i && (i = !0)
      const r = this
      let n = e
      n < 0 && (n = 0)
      const o = r.params
      const l = r.snapGrid
      const d = r.slidesGrid
      const h = r.previousIndex
      const p = r.activeIndex
      const c = r.rtlTranslate
      const u = r.wrapperEl
      if (r.animating && o.preventInteractionOnTransition) return !1
      let v = Math.floor(n / o.slidesPerGroup)
      v >= l.length && (v = l.length - 1),
        (p || o.initialSlide || 0) === (h || 0) &&
          i &&
          r.emit('beforeSlideChangeStart')
      let f
      const m = -l[v]
      if ((r.updateProgress(m), o.normalizeSlideIndex))
        for (let g = 0; g < d.length; g += 1)
          -Math.floor(100 * m) >= Math.floor(100 * d[g]) && (n = g)
      if (r.initialized && n !== p) {
        if (!r.allowSlideNext && m < r.translate && m < r.minTranslate())
          return !1
        if (
          !r.allowSlidePrev &&
          m > r.translate &&
          m > r.maxTranslate() &&
          (p || 0) !== n
        )
          return !1
      }
      if (
        ((f = n > p ? 'next' : n < p ? 'prev' : 'reset'),
        (c && -m === r.translate) || (!c && m === r.translate))
      )
        return (
          r.updateActiveIndex(n),
          o.autoHeight && r.updateAutoHeight(),
          r.updateSlidesClasses(),
          o.effect !== 'slide' && r.setTranslate(m),
          f !== 'reset' && (r.transitionStart(i, f), r.transitionEnd(i, f)),
          !1
        )
      if (o.cssMode) {
        const b = r.isHorizontal()
        return (
          t === 0
            ? (u[b ? 'scrollLeft' : 'scrollTop'] = -m)
            : u.scrollTo
            ? u.scrollTo(
                (((a = {})[b ? 'left' : 'top'] = -m),
                (a.behavior = 'smooth'),
                a)
              )
            : (u[b ? 'scrollLeft' : 'scrollTop'] = -m),
          !0
        )
      }
      return (
        t === 0
          ? (r.setTransition(0),
            r.setTranslate(m),
            r.updateActiveIndex(n),
            r.updateSlidesClasses(),
            r.emit('beforeTransitionStart', t, s),
            r.transitionStart(i, f),
            r.transitionEnd(i, f))
          : (r.setTransition(t),
            r.setTranslate(m),
            r.updateActiveIndex(n),
            r.updateSlidesClasses(),
            r.emit('beforeTransitionStart', t, s),
            r.transitionStart(i, f),
            r.animating ||
              ((r.animating = !0),
              r.onSlideToWrapperTransitionEnd ||
                (r.onSlideToWrapperTransitionEnd = function (e) {
                  r &&
                    !r.destroyed &&
                    e.target === this &&
                    (r.$wrapperEl[0].removeEventListener(
                      'transitionend',
                      r.onSlideToWrapperTransitionEnd
                    ),
                    r.$wrapperEl[0].removeEventListener(
                      'webkitTransitionEnd',
                      r.onSlideToWrapperTransitionEnd
                    ),
                    (r.onSlideToWrapperTransitionEnd = null),
                    delete r.onSlideToWrapperTransitionEnd,
                    r.transitionEnd(i, f))
                }),
              r.$wrapperEl[0].addEventListener(
                'transitionend',
                r.onSlideToWrapperTransitionEnd
              ),
              r.$wrapperEl[0].addEventListener(
                'webkitTransitionEnd',
                r.onSlideToWrapperTransitionEnd
              ))),
        !0
      )
    },
    slideToLoop(e, t, i, s) {
      void 0 === e && (e = 0),
        void 0 === t && (t = this.params.speed),
        void 0 === i && (i = !0)
      let a = e
      return (
        this.params.loop && (a += this.loopedSlides), this.slideTo(a, t, i, s)
      )
    },
    slideNext(e, t, i) {
      void 0 === e && (e = this.params.speed), void 0 === t && (t = !0)
      const s = this.params
      const a = this.animating
      return s.loop
        ? !a &&
            (this.loopFix(),
            (this._clientLeft = this.$wrapperEl[0].clientLeft),
            this.slideTo(this.activeIndex + s.slidesPerGroup, e, t, i))
        : this.slideTo(this.activeIndex + s.slidesPerGroup, e, t, i)
    },
    slidePrev(e, t, i) {
      void 0 === e && (e = this.params.speed), void 0 === t && (t = !0)
      const s = this.params
      const a = this.animating
      const r = this.snapGrid
      const n = this.slidesGrid
      const o = this.rtlTranslate
      if (s.loop) {
        if (a) return !1
        this.loopFix(), (this._clientLeft = this.$wrapperEl[0].clientLeft)
      }
      function l(e) {
        return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
      }
      let d
      const h = l(o ? this.translate : -this.translate)
      const p = r.map(function (e) {
        return l(e)
      })
      let c =
        (n.map(function (e) {
          return l(e)
        }),
        r[p.indexOf(h)],
        r[p.indexOf(h) - 1])
      return (
        void 0 === c &&
          s.cssMode &&
          r.forEach(function (e) {
            !c && h >= e && (c = e)
          }),
        void 0 !== c && (d = n.indexOf(c)) < 0 && (d = this.activeIndex - 1),
        this.slideTo(d, e, t, i)
      )
    },
    slideReset(e, t, i) {
      return (
        void 0 === e && (e = this.params.speed),
        void 0 === t && (t = !0),
        this.slideTo(this.activeIndex, e, t, i)
      )
    },
    slideToClosest(e, t, i, s) {
      void 0 === e && (e = this.params.speed),
        void 0 === t && (t = !0),
        void 0 === s && (s = 0.5)
      let a = this.activeIndex
      const r = Math.floor(a / this.params.slidesPerGroup)
      const n = this.rtlTranslate ? this.translate : -this.translate
      if (n >= this.snapGrid[r]) {
        const o = this.snapGrid[r]
        n - o > (this.snapGrid[r + 1] - o) * s &&
          (a += this.params.slidesPerGroup)
      } else {
        const l = this.snapGrid[r - 1]
        n - l <= (this.snapGrid[r] - l) * s && (a -= this.params.slidesPerGroup)
      }
      return (
        (a = Math.max(a, 0)),
        (a = Math.min(a, this.snapGrid.length - 1)),
        this.slideTo(a, e, t, i)
      )
    },
    slideToClickedSlide() {
      let e
      const t = this
      const i = t.params
      const a = t.$wrapperEl
      const r =
        i.slidesPerView === 'auto' ? t.slidesPerViewDynamic() : i.slidesPerView
      let o = t.clickedIndex
      if (i.loop) {
        if (t.animating) return
        ;(e = parseInt(s(t.clickedSlide).attr('data-swiper-slide-index'), 10)),
          i.centeredSlides
            ? o < t.loopedSlides - r / 2 ||
              o > t.slides.length - t.loopedSlides + r / 2
              ? (t.loopFix(),
                (o = a
                  .children(
                    '.' +
                      i.slideClass +
                      '[data-swiper-slide-index="' +
                      e +
                      '"]:not(.' +
                      i.slideDuplicateClass +
                      ')'
                  )
                  .eq(0)
                  .index()),
                n.nextTick(function () {
                  t.slideTo(o)
                }))
              : t.slideTo(o)
            : o > t.slides.length - r
            ? (t.loopFix(),
              (o = a
                .children(
                  '.' +
                    i.slideClass +
                    '[data-swiper-slide-index="' +
                    e +
                    '"]:not(.' +
                    i.slideDuplicateClass +
                    ')'
                )
                .eq(0)
                .index()),
              n.nextTick(function () {
                t.slideTo(o)
              }))
            : t.slideTo(o)
      } else t.slideTo(o)
    },
  }
  const v = {
    loopCreate() {
      const t = this
      const i = t.params
      const a = t.$wrapperEl
      a.children('.' + i.slideClass + '.' + i.slideDuplicateClass).remove()
      let r = a.children('.' + i.slideClass)
      if (i.loopFillGroupWithBlank) {
        const n = i.slidesPerGroup - (r.length % i.slidesPerGroup)
        if (n !== i.slidesPerGroup) {
          for (let o = 0; o < n; o += 1) {
            const l = s(e.createElement('div')).addClass(
              i.slideClass + ' ' + i.slideBlankClass
            )
            a.append(l)
          }
          r = a.children('.' + i.slideClass)
        }
      }
      i.slidesPerView !== 'auto' ||
        i.loopedSlides ||
        (i.loopedSlides = r.length),
        (t.loopedSlides = Math.ceil(
          parseFloat(i.loopedSlides || i.slidesPerView, 10)
        )),
        (t.loopedSlides += i.loopAdditionalSlides),
        t.loopedSlides > r.length && (t.loopedSlides = r.length)
      const d = []
      const h = []
      r.each(function (e, i) {
        const a = s(i)
        e < t.loopedSlides && h.push(i),
          e < r.length && e >= r.length - t.loopedSlides && d.push(i),
          a.attr('data-swiper-slide-index', e)
      })
      for (let p = 0; p < h.length; p += 1)
        a.append(s(h[p].cloneNode(!0)).addClass(i.slideDuplicateClass))
      for (let c = d.length - 1; c >= 0; c -= 1)
        a.prepend(s(d[c].cloneNode(!0)).addClass(i.slideDuplicateClass))
    },
    loopFix() {
      let e
      const t = this.activeIndex
      const i = this.slides
      const s = this.loopedSlides
      const a = this.allowSlidePrev
      const r = this.allowSlideNext
      const n = this.snapGrid
      const o = this.rtlTranslate
      ;(this.allowSlidePrev = !0), (this.allowSlideNext = !0)
      const l = -n[t] - this.getTranslate()
      if (t < s)
        (e = i.length - 3 * s + t),
          (e += s),
          this.slideTo(e, 0, !1, !0) &&
            l !== 0 &&
            this.setTranslate((o ? -this.translate : this.translate) - l)
      else if (t >= i.length - s) {
        ;(e = -i.length + t + s),
          (e += s),
          this.slideTo(e, 0, !1, !0) &&
            l !== 0 &&
            this.setTranslate((o ? -this.translate : this.translate) - l)
      }
      ;(this.allowSlidePrev = a), (this.allowSlideNext = r)
    },
    loopDestroy() {
      const e = this.$wrapperEl
      const t = this.params
      const i = this.slides
      e
        .children(
          '.' +
            t.slideClass +
            '.' +
            t.slideDuplicateClass +
            ',.' +
            t.slideClass +
            '.' +
            t.slideBlankClass
        )
        .remove(),
        i.removeAttr('data-swiper-slide-index')
    },
  }
  const f = {
    setGrabCursor(e) {
      if (
        !(
          o.touch ||
          !this.params.simulateTouch ||
          (this.params.watchOverflow && this.isLocked) ||
          this.params.cssMode
        )
      ) {
        const t = this.el
        ;(t.style.cursor = 'move'),
          (t.style.cursor = e ? '-webkit-grabbing' : '-webkit-grab'),
          (t.style.cursor = e ? '-moz-grabbin' : '-moz-grab'),
          (t.style.cursor = e ? 'grabbing' : 'grab')
      }
    },
    unsetGrabCursor() {
      o.touch ||
        (this.params.watchOverflow && this.isLocked) ||
        this.params.cssMode ||
        (this.el.style.cursor = '')
    },
  }
  let m
  let g
  let b
  let w
  let y
  let x
  let T
  let E
  let C
  let S
  let M
  let P
  let z
  let k
  let $
  const L = {
    appendSlide(e) {
      const t = this.$wrapperEl
      const i = this.params
      if (
        (i.loop && this.loopDestroy(), typeof e === 'object' && 'length' in e)
      )
        for (let s = 0; s < e.length; s += 1) e[s] && t.append(e[s])
      else t.append(e)
      i.loop && this.loopCreate(), (i.observer && o.observer) || this.update()
    },
    prependSlide(e) {
      const t = this.params
      const i = this.$wrapperEl
      const s = this.activeIndex
      t.loop && this.loopDestroy()
      let a = s + 1
      if (typeof e === 'object' && 'length' in e) {
        for (let r = 0; r < e.length; r += 1) e[r] && i.prepend(e[r])
        a = s + e.length
      } else i.prepend(e)
      t.loop && this.loopCreate(),
        (t.observer && o.observer) || this.update(),
        this.slideTo(a, 0, !1)
    },
    addSlide(e, t) {
      const i = this.$wrapperEl
      const s = this.params
      let a = this.activeIndex
      s.loop &&
        ((a -= this.loopedSlides),
        this.loopDestroy(),
        (this.slides = i.children('.' + s.slideClass)))
      const r = this.slides.length
      if (e <= 0) this.prependSlide(t)
      else if (e >= r) this.appendSlide(t)
      else {
        for (var n = a > e ? a + 1 : a, l = [], d = r - 1; d >= e; d -= 1) {
          const h = this.slides.eq(d)
          h.remove(), l.unshift(h)
        }
        if (typeof t === 'object' && 'length' in t) {
          for (let p = 0; p < t.length; p += 1) t[p] && i.append(t[p])
          n = a > e ? a + t.length : a
        } else i.append(t)
        for (let c = 0; c < l.length; c += 1) i.append(l[c])
        s.loop && this.loopCreate(),
          (s.observer && o.observer) || this.update(),
          s.loop
            ? this.slideTo(n + this.loopedSlides, 0, !1)
            : this.slideTo(n, 0, !1)
      }
    },
    removeSlide(e) {
      const t = this.params
      const i = this.$wrapperEl
      let s = this.activeIndex
      t.loop &&
        ((s -= this.loopedSlides),
        this.loopDestroy(),
        (this.slides = i.children('.' + t.slideClass)))
      let a
      let r = s
      if (typeof e === 'object' && 'length' in e) {
        for (let n = 0; n < e.length; n += 1)
          (a = e[n]),
            this.slides[a] && this.slides.eq(a).remove(),
            a < r && (r -= 1)
        r = Math.max(r, 0)
      } else
        (a = e),
          this.slides[a] && this.slides.eq(a).remove(),
          a < r && (r -= 1),
          (r = Math.max(r, 0))
      t.loop && this.loopCreate(),
        (t.observer && o.observer) || this.update(),
        t.loop
          ? this.slideTo(r + this.loopedSlides, 0, !1)
          : this.slideTo(r, 0, !1)
    },
    removeAllSlides() {
      for (var e = [], t = 0; t < this.slides.length; t += 1) e.push(t)
      this.removeSlide(e)
    },
  }
  const I =
    ((m = t.navigator.platform),
    (g = t.navigator.userAgent),
    (b = {
      ios: !1,
      android: !1,
      androidChrome: !1,
      desktop: !1,
      iphone: !1,
      ipod: !1,
      ipad: !1,
      edge: !1,
      ie: !1,
      firefox: !1,
      macos: !1,
      windows: !1,
      cordova: !(!t.cordova && !t.phonegap),
      phonegap: !(!t.cordova && !t.phonegap),
      electron: !1,
    }),
    (w = t.screen.width),
    (y = t.screen.height),
    (x = g.match(/(Android);?[\s\/]+([\d.]+)?/)),
    (T = g.match(/(iPad).*OS\s([\d_]+)/)),
    (E = g.match(/(iPod)(.*OS\s([\d_]+))?/)),
    (C = !T && g.match(/(iPhone\sOS|iOS)\s([\d_]+)/)),
    (S = g.includes('MSIE ') || g.includes('Trident/')),
    (M = g.includes('Edge/')),
    (P = g.includes('Gecko/') && g.includes('Firefox/')),
    (z = m === 'Win32'),
    (k = g.toLowerCase().includes('electron')),
    ($ = m === 'MacIntel'),
    !T &&
      $ &&
      o.touch &&
      ((w === 1024 && y === 1366) ||
        (w === 834 && y === 1194) ||
        (w === 834 && y === 1112) ||
        (w === 768 && y === 1024)) &&
      ((T = g.match(/(Version)\/([\d.]+)/)), ($ = !1)),
    (b.ie = S),
    (b.edge = M),
    (b.firefox = P),
    x &&
      !z &&
      ((b.os = 'android'),
      (b.osVersion = x[2]),
      (b.android = !0),
      (b.androidChrome = g.toLowerCase().includes('chrome'))),
    (T || C || E) && ((b.os = 'ios'), (b.ios = !0)),
    C && !E && ((b.osVersion = C[2].replace(/_/g, '.')), (b.iphone = !0)),
    T && ((b.osVersion = T[2].replace(/_/g, '.')), (b.ipad = !0)),
    E && ((b.osVersion = E[3] ? E[3].replace(/_/g, '.') : null), (b.ipod = !0)),
    b.ios &&
      b.osVersion &&
      g.includes('Version/') &&
      b.osVersion.split('.')[0] === '10' &&
      (b.osVersion = g.toLowerCase().split('version/')[1].split(' ')[0]),
    (b.webView =
      !(
        !(C || T || E) ||
        (!g.match(/.*AppleWebKit(?!.*Safari)/i) && !t.navigator.standalone)
      ) ||
      (t.matchMedia && t.matchMedia('(display-mode: standalone)').matches)),
    (b.webview = b.webView),
    (b.standalone = b.webView),
    (b.desktop = !(b.ios || b.android) || k),
    b.desktop &&
      ((b.electron = k),
      (b.macos = $),
      (b.windows = z),
      b.macos && (b.os = 'macos'),
      b.windows && (b.os = 'windows')),
    (b.pixelRatio = t.devicePixelRatio || 1),
    b)
  function D(i) {
    const a = this.touchEventsData
    const r = this.params
    const o = this.touches
    if (!this.animating || !r.preventInteractionOnTransition) {
      let l = i
      l.originalEvent && (l = l.originalEvent)
      const d = s(l.target)
      if (
        (r.touchEventsTarget !== 'wrapper' ||
          d.closest(this.wrapperEl).length) &&
        ((a.isTouchEvent = l.type === 'touchstart'),
        (a.isTouchEvent || !('which' in l) || l.which !== 3) &&
          !(
            (!a.isTouchEvent && 'button' in l && l.button > 0) ||
            (a.isTouched && a.isMoved)
          ))
      )
        if (
          r.noSwiping &&
          d.closest(
            r.noSwipingSelector ? r.noSwipingSelector : '.' + r.noSwipingClass
          )[0]
        )
          this.allowClick = !0
        else if (!r.swipeHandler || d.closest(r.swipeHandler)[0]) {
          ;(o.currentX =
            l.type === 'touchstart' ? l.targetTouches[0].pageX : l.pageX),
            (o.currentY =
              l.type === 'touchstart' ? l.targetTouches[0].pageY : l.pageY)
          const h = o.currentX
          const p = o.currentY
          const c = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection
          const u = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold
          if (!c || !(h <= u || h >= t.screen.width - u)) {
            if (
              (n.extend(a, {
                isTouched: !0,
                isMoved: !1,
                allowTouchCallbacks: !0,
                isScrolling: void 0,
                startMoving: void 0,
              }),
              (o.startX = h),
              (o.startY = p),
              (a.touchStartTime = n.now()),
              (this.allowClick = !0),
              this.updateSize(),
              (this.swipeDirection = void 0),
              r.threshold > 0 && (a.allowThresholdMove = !1),
              l.type !== 'touchstart')
            ) {
              let v = !0
              d.is(a.formElements) && (v = !1),
                e.activeElement &&
                  s(e.activeElement).is(a.formElements) &&
                  e.activeElement !== d[0] &&
                  e.activeElement.blur()
              const f = v && this.allowTouchMove && r.touchStartPreventDefault
              ;(r.touchStartForcePreventDefault || f) && l.preventDefault()
            }
            this.emit('touchStart', l)
          }
        }
    }
  }
  function O(t) {
    const i = this.touchEventsData
    const a = this.params
    const r = this.touches
    const o = this.rtlTranslate
    let l = t
    if ((l.originalEvent && (l = l.originalEvent), i.isTouched)) {
      if (!i.isTouchEvent || l.type !== 'mousemove') {
        const d =
          l.type === 'touchmove' &&
          l.targetTouches &&
          (l.targetTouches[0] || l.changedTouches[0])
        const h = l.type === 'touchmove' ? d.pageX : l.pageX
        const p = l.type === 'touchmove' ? d.pageY : l.pageY
        if (l.preventedByNestedSwiper)
          return (r.startX = h), void (r.startY = p)
        if (!this.allowTouchMove)
          return (
            (this.allowClick = !1),
            void (
              i.isTouched &&
              (n.extend(r, { startX: h, startY: p, currentX: h, currentY: p }),
              (i.touchStartTime = n.now()))
            )
          )
        if (i.isTouchEvent && a.touchReleaseOnEdges && !a.loop)
          if (this.isVertical()) {
            if (
              (p < r.startY && this.translate <= this.maxTranslate()) ||
              (p > r.startY && this.translate >= this.minTranslate())
            )
              return (i.isTouched = !1), void (i.isMoved = !1)
          } else if (
            (h < r.startX && this.translate <= this.maxTranslate()) ||
            (h > r.startX && this.translate >= this.minTranslate())
          )
            return
        if (
          i.isTouchEvent &&
          e.activeElement &&
          l.target === e.activeElement &&
          s(l.target).is(i.formElements)
        )
          return (i.isMoved = !0), void (this.allowClick = !1)
        if (
          (i.allowTouchCallbacks && this.emit('touchMove', l),
          !(l.targetTouches && l.targetTouches.length > 1))
        ) {
          ;(r.currentX = h), (r.currentY = p)
          const c = r.currentX - r.startX
          const u = r.currentY - r.startY
          if (
            !(
              this.params.threshold &&
              Math.sqrt(Math.pow(c, 2) + Math.pow(u, 2)) < this.params.threshold
            )
          ) {
            let v
            if (void 0 === i.isScrolling)
              (this.isHorizontal() && r.currentY === r.startY) ||
              (this.isVertical() && r.currentX === r.startX)
                ? (i.isScrolling = !1)
                : c * c + u * u >= 25 &&
                  ((v = (180 * Math.atan2(Math.abs(u), Math.abs(c))) / Math.PI),
                  (i.isScrolling = this.isHorizontal()
                    ? v > a.touchAngle
                    : 90 - v > a.touchAngle))
            if (
              (i.isScrolling && this.emit('touchMoveOpposite', l),
              void 0 === i.startMoving &&
                ((r.currentX === r.startX && r.currentY === r.startY) ||
                  (i.startMoving = !0)),
              i.isScrolling)
            )
              i.isTouched = !1
            else if (i.startMoving) {
              ;(this.allowClick = !1),
                a.cssMode || l.preventDefault(),
                a.touchMoveStopPropagation && !a.nested && l.stopPropagation(),
                i.isMoved ||
                  (a.loop && this.loopFix(),
                  (i.startTranslate = this.getTranslate()),
                  this.setTransition(0),
                  this.animating &&
                    this.$wrapperEl.trigger(
                      'webkitTransitionEnd transitionend'
                    ),
                  (i.allowMomentumBounce = !1),
                  !a.grabCursor ||
                    (!0 !== this.allowSlideNext &&
                      !0 !== this.allowSlidePrev) ||
                    this.setGrabCursor(!0),
                  this.emit('sliderFirstMove', l)),
                this.emit('sliderMove', l),
                (i.isMoved = !0)
              let f = this.isHorizontal() ? c : u
              ;(r.diff = f),
                (f *= a.touchRatio),
                o && (f = -f),
                (this.swipeDirection = f > 0 ? 'prev' : 'next'),
                (i.currentTranslate = f + i.startTranslate)
              let m = !0
              let g = a.resistanceRatio
              if (
                (a.touchReleaseOnEdges && (g = 0),
                f > 0 && i.currentTranslate > this.minTranslate()
                  ? ((m = !1),
                    a.resistance &&
                      (i.currentTranslate =
                        this.minTranslate() -
                        1 +
                        Math.pow(
                          -this.minTranslate() + i.startTranslate + f,
                          g
                        )))
                  : f < 0 &&
                    i.currentTranslate < this.maxTranslate() &&
                    ((m = !1),
                    a.resistance &&
                      (i.currentTranslate =
                        this.maxTranslate() +
                        1 -
                        Math.pow(
                          this.maxTranslate() - i.startTranslate - f,
                          g
                        ))),
                m && (l.preventedByNestedSwiper = !0),
                !this.allowSlideNext &&
                  this.swipeDirection === 'next' &&
                  i.currentTranslate < i.startTranslate &&
                  (i.currentTranslate = i.startTranslate),
                !this.allowSlidePrev &&
                  this.swipeDirection === 'prev' &&
                  i.currentTranslate > i.startTranslate &&
                  (i.currentTranslate = i.startTranslate),
                a.threshold > 0)
              ) {
                if (!(Math.abs(f) > a.threshold || i.allowThresholdMove))
                  return void (i.currentTranslate = i.startTranslate)
                if (!i.allowThresholdMove)
                  return (
                    (i.allowThresholdMove = !0),
                    (r.startX = r.currentX),
                    (r.startY = r.currentY),
                    (i.currentTranslate = i.startTranslate),
                    void (r.diff = this.isHorizontal()
                      ? r.currentX - r.startX
                      : r.currentY - r.startY)
                  )
              }
              a.followFinger &&
                !a.cssMode &&
                ((a.freeMode ||
                  a.watchSlidesProgress ||
                  a.watchSlidesVisibility) &&
                  (this.updateActiveIndex(), this.updateSlidesClasses()),
                a.freeMode &&
                  (i.velocities.length === 0 &&
                    i.velocities.push({
                      position: r[this.isHorizontal() ? 'startX' : 'startY'],
                      time: i.touchStartTime,
                    }),
                  i.velocities.push({
                    position: r[this.isHorizontal() ? 'currentX' : 'currentY'],
                    time: n.now(),
                  })),
                this.updateProgress(i.currentTranslate),
                this.setTranslate(i.currentTranslate))
            }
          }
        }
      }
    } else i.startMoving && i.isScrolling && this.emit('touchMoveOpposite', l)
  }
  function A(e) {
    const t = this
    const i = t.touchEventsData
    const s = t.params
    const a = t.touches
    const r = t.rtlTranslate
    const o = t.$wrapperEl
    const l = t.slidesGrid
    const d = t.snapGrid
    let h = e
    if (
      (h.originalEvent && (h = h.originalEvent),
      i.allowTouchCallbacks && t.emit('touchEnd', h),
      (i.allowTouchCallbacks = !1),
      !i.isTouched)
    )
      return (
        i.isMoved && s.grabCursor && t.setGrabCursor(!1),
        (i.isMoved = !1),
        void (i.startMoving = !1)
      )
    s.grabCursor &&
      i.isMoved &&
      i.isTouched &&
      (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) &&
      t.setGrabCursor(!1)
    let p
    const c = n.now()
    const u = c - i.touchStartTime
    if (
      (t.allowClick &&
        (t.updateClickedSlide(h),
        t.emit('tap click', h),
        u < 300 &&
          c - i.lastClickTime < 300 &&
          t.emit('doubleTap doubleClick', h)),
      (i.lastClickTime = n.now()),
      n.nextTick(function () {
        t.destroyed || (t.allowClick = !0)
      }),
      !i.isTouched ||
        !i.isMoved ||
        !t.swipeDirection ||
        a.diff === 0 ||
        i.currentTranslate === i.startTranslate)
    )
      return (i.isTouched = !1), (i.isMoved = !1), void (i.startMoving = !1)
    if (
      ((i.isTouched = !1),
      (i.isMoved = !1),
      (i.startMoving = !1),
      (p = s.followFinger
        ? r
          ? t.translate
          : -t.translate
        : -i.currentTranslate),
      !s.cssMode)
    )
      if (s.freeMode) {
        if (p < -t.minTranslate()) return void t.slideTo(t.activeIndex)
        if (p > -t.maxTranslate())
          return void (t.slides.length < d.length
            ? t.slideTo(d.length - 1)
            : t.slideTo(t.slides.length - 1))
        if (s.freeModeMomentum) {
          if (i.velocities.length > 1) {
            const v = i.velocities.pop()
            const f = i.velocities.pop()
            const m = v.position - f.position
            const g = v.time - f.time
            ;(t.velocity = m / g),
              (t.velocity /= 2),
              Math.abs(t.velocity) < s.freeModeMinimumVelocity &&
                (t.velocity = 0),
              (g > 150 || n.now() - v.time > 300) && (t.velocity = 0)
          } else t.velocity = 0
          ;(t.velocity *= s.freeModeMomentumVelocityRatio),
            (i.velocities.length = 0)
          let b = 1e3 * s.freeModeMomentumRatio
          const w = t.velocity * b
          let y = t.translate + w
          r && (y = -y)
          let x
          let T
          let E = !1
          const C = 20 * Math.abs(t.velocity) * s.freeModeMomentumBounceRatio
          if (y < t.maxTranslate())
            s.freeModeMomentumBounce
              ? (y + t.maxTranslate() < -C && (y = t.maxTranslate() - C),
                (x = t.maxTranslate()),
                (E = !0),
                (i.allowMomentumBounce = !0))
              : (y = t.maxTranslate()),
              s.loop && s.centeredSlides && (T = !0)
          else if (y > t.minTranslate())
            s.freeModeMomentumBounce
              ? (y - t.minTranslate() > C && (y = t.minTranslate() + C),
                (x = t.minTranslate()),
                (E = !0),
                (i.allowMomentumBounce = !0))
              : (y = t.minTranslate()),
              s.loop && s.centeredSlides && (T = !0)
          else if (s.freeModeSticky) {
            for (var S, M = 0; M < d.length; M += 1)
              if (d[M] > -y) {
                S = M
                break
              }
            y = -(y =
              Math.abs(d[S] - y) < Math.abs(d[S - 1] - y) ||
              t.swipeDirection === 'next'
                ? d[S]
                : d[S - 1])
          }
          if (
            (T &&
              t.once('transitionEnd', function () {
                t.loopFix()
              }),
            t.velocity !== 0)
          ) {
            if (
              ((b = r
                ? Math.abs((-y - t.translate) / t.velocity)
                : Math.abs((y - t.translate) / t.velocity)),
              s.freeModeSticky)
            ) {
              const P = Math.abs((r ? -y : y) - t.translate)
              const z = t.slidesSizesGrid[t.activeIndex]
              b = P < z ? s.speed : P < 2 * z ? 1.5 * s.speed : 2.5 * s.speed
            }
          } else if (s.freeModeSticky) return void t.slideToClosest()
          s.freeModeMomentumBounce && E
            ? (t.updateProgress(x),
              t.setTransition(b),
              t.setTranslate(y),
              t.transitionStart(!0, t.swipeDirection),
              (t.animating = !0),
              o.transitionEnd(function () {
                t &&
                  !t.destroyed &&
                  i.allowMomentumBounce &&
                  (t.emit('momentumBounce'),
                  t.setTransition(s.speed),
                  t.setTranslate(x),
                  o.transitionEnd(function () {
                    t && !t.destroyed && t.transitionEnd()
                  }))
              }))
            : t.velocity
            ? (t.updateProgress(y),
              t.setTransition(b),
              t.setTranslate(y),
              t.transitionStart(!0, t.swipeDirection),
              t.animating ||
                ((t.animating = !0),
                o.transitionEnd(function () {
                  t && !t.destroyed && t.transitionEnd()
                })))
            : t.updateProgress(y),
            t.updateActiveIndex(),
            t.updateSlidesClasses()
        } else if (s.freeModeSticky) return void t.slideToClosest()
        ;(!s.freeModeMomentum || u >= s.longSwipesMs) &&
          (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())
      } else {
        for (
          var k = 0, $ = t.slidesSizesGrid[0], L = 0;
          L < l.length;
          L += s.slidesPerGroup
        )
          void 0 !== l[L + s.slidesPerGroup]
            ? p >= l[L] &&
              p < l[L + s.slidesPerGroup] &&
              ((k = L), ($ = l[L + s.slidesPerGroup] - l[L]))
            : p >= l[L] && ((k = L), ($ = l[l.length - 1] - l[l.length - 2]))
        const I = (p - l[k]) / $
        if (u > s.longSwipesMs) {
          if (!s.longSwipes) return void t.slideTo(t.activeIndex)
          t.swipeDirection === 'next' &&
            (I >= s.longSwipesRatio
              ? t.slideTo(k + s.slidesPerGroup)
              : t.slideTo(k)),
            t.swipeDirection === 'prev' &&
              (I > 1 - s.longSwipesRatio
                ? t.slideTo(k + s.slidesPerGroup)
                : t.slideTo(k))
        } else {
          if (!s.shortSwipes) return void t.slideTo(t.activeIndex)
          t.navigation &&
          (h.target === t.navigation.nextEl || h.target === t.navigation.prevEl)
            ? h.target === t.navigation.nextEl
              ? t.slideTo(k + s.slidesPerGroup)
              : t.slideTo(k)
            : (t.swipeDirection === 'next' && t.slideTo(k + s.slidesPerGroup),
              t.swipeDirection === 'prev' && t.slideTo(k))
        }
      }
  }
  function G() {
    const e = this.params
    const t = this.el
    if (!t || t.offsetWidth !== 0) {
      e.breakpoints && this.setBreakpoint()
      const i = this.allowSlideNext
      const s = this.allowSlidePrev
      const a = this.snapGrid
      ;(this.allowSlideNext = !0),
        (this.allowSlidePrev = !0),
        this.updateSize(),
        this.updateSlides(),
        this.updateSlidesClasses(),
        (e.slidesPerView === 'auto' || e.slidesPerView > 1) &&
        this.isEnd &&
        !this.params.centeredSlides
          ? this.slideTo(this.slides.length - 1, 0, !1, !0)
          : this.slideTo(this.activeIndex, 0, !1, !0),
        this.autoplay &&
          this.autoplay.running &&
          this.autoplay.paused &&
          this.autoplay.run(),
        (this.allowSlidePrev = s),
        (this.allowSlideNext = i),
        this.params.watchOverflow && a !== this.snapGrid && this.checkOverflow()
    }
  }
  function B(e) {
    this.allowClick ||
      (this.params.preventClicks && e.preventDefault(),
      this.params.preventClicksPropagation &&
        this.animating &&
        (e.stopPropagation(), e.stopImmediatePropagation()))
  }
  function H() {
    const e = this.wrapperEl
    ;(this.previousTranslate = this.translate),
      (this.translate = this.isHorizontal() ? -e.scrollLeft : -e.scrollTop),
      this.translate === -0 && (this.translate = 0),
      this.updateActiveIndex(),
      this.updateSlidesClasses()
    const t = this.maxTranslate() - this.minTranslate()
    ;(t === 0 ? 0 : (this.translate - this.minTranslate()) / t) !==
      this.progress && this.updateProgress(this.translate),
      this.emit('setTranslate', this.translate, !1)
  }
  let N = !1
  function X() {}
  const V = {
    init: !0,
    direction: 'horizontal',
    touchEventsTarget: 'container',
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    preventInteractionOnTransition: !1,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    freeMode: !1,
    freeModeMomentum: !0,
    freeModeMomentumRatio: 1,
    freeModeMomentumBounce: !0,
    freeModeMomentumBounceRatio: 1,
    freeModeMomentumVelocityRatio: 1,
    freeModeSticky: !1,
    freeModeMinimumVelocity: 0.02,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: 'slide',
    breakpoints: void 0,
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerColumn: 1,
    slidesPerColumnFill: 'column',
    slidesPerGroup: 1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !1,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 0,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: 0.85,
    watchSlidesProgress: !1,
    watchSlidesVisibility: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    preloadImages: !0,
    updateOnImagesReady: !0,
    loop: !1,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopFillGroupWithBlank: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: 'swiper-no-swiping',
    noSwipingSelector: null,
    passiveListeners: !0,
    containerModifierClass: 'swiper-container-',
    slideClass: 'swiper-slide',
    slideBlankClass: 'swiper-slide-invisible-blank',
    slideActiveClass: 'swiper-slide-active',
    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
    slideVisibleClass: 'swiper-slide-visible',
    slideDuplicateClass: 'swiper-slide-duplicate',
    slideNextClass: 'swiper-slide-next',
    slideDuplicateNextClass: 'swiper-slide-duplicate-next',
    slidePrevClass: 'swiper-slide-prev',
    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
    wrapperClass: 'swiper-wrapper',
    runCallbacksOnInit: !0,
  }
  const Y = {
    update: h,
    translate: p,
    transition: c,
    slide: u,
    loop: v,
    grabCursor: f,
    manipulation: L,
    events: {
      attachEvents() {
        const t = this.params
        const i = this.touchEvents
        const s = this.el
        const a = this.wrapperEl
        ;(this.onTouchStart = D.bind(this)),
          (this.onTouchMove = O.bind(this)),
          (this.onTouchEnd = A.bind(this)),
          t.cssMode && (this.onScroll = H.bind(this)),
          (this.onClick = B.bind(this))
        const r = !!t.nested
        if (!o.touch && o.pointerEvents)
          s.addEventListener(i.start, this.onTouchStart, !1),
            e.addEventListener(i.move, this.onTouchMove, r),
            e.addEventListener(i.end, this.onTouchEnd, !1)
        else {
          if (o.touch) {
            const n = !(
              i.start !== 'touchstart' ||
              !o.passiveListener ||
              !t.passiveListeners
            ) && { passive: !0, capture: !1 }
            s.addEventListener(i.start, this.onTouchStart, n),
              s.addEventListener(
                i.move,
                this.onTouchMove,
                o.passiveListener ? { passive: !1, capture: r } : r
              ),
              s.addEventListener(i.end, this.onTouchEnd, n),
              i.cancel && s.addEventListener(i.cancel, this.onTouchEnd, n),
              N || (e.addEventListener('touchstart', X), (N = !0))
          }
          ;((t.simulateTouch && !I.ios && !I.android) ||
            (t.simulateTouch && !o.touch && I.ios)) &&
            (s.addEventListener('mousedown', this.onTouchStart, !1),
            e.addEventListener('mousemove', this.onTouchMove, r),
            e.addEventListener('mouseup', this.onTouchEnd, !1))
        }
        ;(t.preventClicks || t.preventClicksPropagation) &&
          s.addEventListener('click', this.onClick, !0),
          t.cssMode && a.addEventListener('scroll', this.onScroll),
          this.on(
            I.ios || I.android
              ? 'resize orientationchange observerUpdate'
              : 'resize observerUpdate',
            G,
            !0
          )
      },
      detachEvents() {
        const t = this.params
        const i = this.touchEvents
        const s = this.el
        const a = this.wrapperEl
        const r = !!t.nested
        if (!o.touch && o.pointerEvents)
          s.removeEventListener(i.start, this.onTouchStart, !1),
            e.removeEventListener(i.move, this.onTouchMove, r),
            e.removeEventListener(i.end, this.onTouchEnd, !1)
        else {
          if (o.touch) {
            const n = !(
              i.start !== 'onTouchStart' ||
              !o.passiveListener ||
              !t.passiveListeners
            ) && { passive: !0, capture: !1 }
            s.removeEventListener(i.start, this.onTouchStart, n),
              s.removeEventListener(i.move, this.onTouchMove, r),
              s.removeEventListener(i.end, this.onTouchEnd, n),
              i.cancel && s.removeEventListener(i.cancel, this.onTouchEnd, n)
          }
          ;((t.simulateTouch && !I.ios && !I.android) ||
            (t.simulateTouch && !o.touch && I.ios)) &&
            (s.removeEventListener('mousedown', this.onTouchStart, !1),
            e.removeEventListener('mousemove', this.onTouchMove, r),
            e.removeEventListener('mouseup', this.onTouchEnd, !1))
        }
        ;(t.preventClicks || t.preventClicksPropagation) &&
          s.removeEventListener('click', this.onClick, !0),
          t.cssMode && a.removeEventListener('scroll', this.onScroll),
          this.off(
            I.ios || I.android
              ? 'resize orientationchange observerUpdate'
              : 'resize observerUpdate',
            G
          )
      },
    },
    breakpoints: {
      setBreakpoint() {
        const e = this.activeIndex
        const t = this.initialized
        let i = this.loopedSlides
        void 0 === i && (i = 0)
        const s = this.params
        const a = this.$el
        const r = s.breakpoints
        if (r && (!r || Object.keys(r).length !== 0)) {
          const o = this.getBreakpoint(r)
          if (o && this.currentBreakpoint !== o) {
            const l = o in r ? r[o] : void 0
            l &&
              [
                'slidesPerView',
                'spaceBetween',
                'slidesPerGroup',
                'slidesPerColumn',
              ].forEach(function (e) {
                const t = l[e]
                void 0 !== t &&
                  (l[e] =
                    e !== 'slidesPerView' || (t !== 'AUTO' && t !== 'auto')
                      ? e === 'slidesPerView'
                        ? parseFloat(t)
                        : parseInt(t, 10)
                      : 'auto')
              })
            const d = l || this.originalParams
            const h = s.slidesPerColumn > 1
            const p = d.slidesPerColumn > 1
            h && !p
              ? a.removeClass(
                  s.containerModifierClass +
                    'multirow ' +
                    s.containerModifierClass +
                    'multirow-column'
                )
              : !h &&
                p &&
                (a.addClass(s.containerModifierClass + 'multirow'),
                d.slidesPerColumnFill === 'column' &&
                  a.addClass(s.containerModifierClass + 'multirow-column'))
            const c = d.direction && d.direction !== s.direction
            const u = s.loop && (d.slidesPerView !== s.slidesPerView || c)
            c && t && this.changeDirection(),
              n.extend(this.params, d),
              n.extend(this, {
                allowTouchMove: this.params.allowTouchMove,
                allowSlideNext: this.params.allowSlideNext,
                allowSlidePrev: this.params.allowSlidePrev,
              }),
              (this.currentBreakpoint = o),
              u &&
                t &&
                (this.loopDestroy(),
                this.loopCreate(),
                this.updateSlides(),
                this.slideTo(e - i + this.loopedSlides, 0, !1)),
              this.emit('breakpoint', d)
          }
        }
      },
      getBreakpoint(e) {
        if (e) {
          let i = !1
          const s = []
          Object.keys(e).forEach(function (e) {
            s.push(e)
          }),
            s.sort(function (e, t) {
              return parseInt(e, 10) - parseInt(t, 10)
            })
          for (let a = 0; a < s.length; a += 1) {
            const r = s[a]
            r <= t.innerWidth && (i = r)
          }
          return i || 'max'
        }
      },
    },
    checkOverflow: {
      checkOverflow() {
        const e = this.params
        const t = this.isLocked
        const i =
          this.slides.length > 0 &&
          e.slidesOffsetBefore +
            e.spaceBetween * (this.slides.length - 1) +
            this.slides[0].offsetWidth * this.slides.length
        e.slidesOffsetBefore && e.slidesOffsetAfter && i
          ? (this.isLocked = i <= this.size)
          : (this.isLocked = this.snapGrid.length === 1),
          (this.allowSlideNext = !this.isLocked),
          (this.allowSlidePrev = !this.isLocked),
          t !== this.isLocked && this.emit(this.isLocked ? 'lock' : 'unlock'),
          t &&
            t !== this.isLocked &&
            ((this.isEnd = !1), this.navigation.update())
      },
    },
    classes: {
      addClasses() {
        const e = this.classNames
        const t = this.params
        const i = this.rtl
        const s = this.$el
        const a = []
        a.push('initialized'),
          a.push(t.direction),
          t.freeMode && a.push('free-mode'),
          t.autoHeight && a.push('autoheight'),
          i && a.push('rtl'),
          t.slidesPerColumn > 1 &&
            (a.push('multirow'),
            t.slidesPerColumnFill === 'column' && a.push('multirow-column')),
          I.android && a.push('android'),
          I.ios && a.push('ios'),
          t.cssMode && a.push('css-mode'),
          a.forEach(function (i) {
            e.push(t.containerModifierClass + i)
          }),
          s.addClass(e.join(' '))
      },
      removeClasses() {
        const e = this.$el
        const t = this.classNames
        e.removeClass(t.join(' '))
      },
    },
    images: {
      loadImage(e, i, s, a, r, n) {
        let o
        function l() {
          n && n()
        }
        e.complete && r
          ? l()
          : i
          ? (((o = new t.Image()).onload = l),
            (o.onerror = l),
            a && (o.sizes = a),
            s && (o.srcset = s),
            i && (o.src = i))
          : l()
      },
      preloadImages() {
        const e = this
        function t() {
          e != null &&
            e &&
            !e.destroyed &&
            (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1),
            e.imagesLoaded === e.imagesToLoad.length &&
              (e.params.updateOnImagesReady && e.update(),
              e.emit('imagesReady')))
        }
        e.imagesToLoad = e.$el.find('img')
        for (let i = 0; i < e.imagesToLoad.length; i += 1) {
          const s = e.imagesToLoad[i]
          e.loadImage(
            s,
            s.currentSrc || s.getAttribute('src'),
            s.srcset || s.getAttribute('srcset'),
            s.sizes || s.getAttribute('sizes'),
            !0,
            t
          )
        }
      },
    },
  }
  const F = {}
  const W = (function (e) {
    function t() {
      for (var i, a, r, l = [], d = arguments.length; d--; ) l[d] = arguments[d]
      l.length === 1 && l[0].constructor && l[0].constructor === Object
        ? (r = l[0])
        : ((a = (i = l)[0]), (r = i[1])),
        r || (r = {}),
        (r = n.extend({}, r)),
        a && !r.el && (r.el = a),
        e.call(this, r),
        Object.keys(Y).forEach(function (e) {
          Object.keys(Y[e]).forEach(function (i) {
            t.prototype[i] || (t.prototype[i] = Y[e][i])
          })
        })
      const h = this
      void 0 === h.modules && (h.modules = {}),
        Object.keys(h.modules).forEach(function (e) {
          const t = h.modules[e]
          if (t.params) {
            const i = Object.keys(t.params)[0]
            const s = t.params[i]
            if (typeof s !== 'object' || s === null) return
            if (!(i in r && 'enabled' in s)) return
            !0 === r[i] && (r[i] = { enabled: !0 }),
              typeof r[i] !== 'object' ||
                'enabled' in r[i] ||
                (r[i].enabled = !0),
              r[i] || (r[i] = { enabled: !1 })
          }
        })
      const p = n.extend({}, V)
      h.useModulesParams(p),
        (h.params = n.extend({}, p, F, r)),
        (h.originalParams = n.extend({}, h.params)),
        (h.passedParams = n.extend({}, r)),
        (h.$ = s)
      const c = s(h.params.el)
      if ((a = c[0])) {
        if (c.length > 1) {
          const u = []
          return (
            c.each(function (e, i) {
              const s = n.extend({}, r, { el: i })
              u.push(new t(s))
            }),
            u
          )
        }
        let v, f, m
        return (
          (a.swiper = h),
          c.data('swiper', h),
          a && a.shadowRoot && a.shadowRoot.querySelector
            ? ((v = s(
                a.shadowRoot.querySelector('.' + h.params.wrapperClass)
              )).children = function (e) {
                return c.children(e)
              })
            : (v = c.children('.' + h.params.wrapperClass)),
          n.extend(h, {
            $el: c,
            el: a,
            $wrapperEl: v,
            wrapperEl: v[0],
            classNames: [],
            slides: s(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
              return h.params.direction === 'horizontal'
            },
            isVertical() {
              return h.params.direction === 'vertical'
            },
            rtl: a.dir.toLowerCase() === 'rtl' || c.css('direction') === 'rtl',
            rtlTranslate:
              h.params.direction === 'horizontal' &&
              (a.dir.toLowerCase() === 'rtl' || c.css('direction') === 'rtl'),
            wrongRTL: v.css('display') === '-webkit-box',
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            allowSlideNext: h.params.allowSlideNext,
            allowSlidePrev: h.params.allowSlidePrev,
            touchEvents:
              ((f = ['touchstart', 'touchmove', 'touchend', 'touchcancel']),
              (m = ['mousedown', 'mousemove', 'mouseup']),
              o.pointerEvents &&
                (m = ['pointerdown', 'pointermove', 'pointerup']),
              (h.touchEventsTouch = {
                start: f[0],
                move: f[1],
                end: f[2],
                cancel: f[3],
              }),
              (h.touchEventsDesktop = { start: m[0], move: m[1], end: m[2] }),
              o.touch || !h.params.simulateTouch
                ? h.touchEventsTouch
                : h.touchEventsDesktop),
            touchEventsData: {
              isTouched: void 0,
              isMoved: void 0,
              allowTouchCallbacks: void 0,
              touchStartTime: void 0,
              isScrolling: void 0,
              currentTranslate: void 0,
              startTranslate: void 0,
              allowThresholdMove: void 0,
              formElements: 'input, select, option, textarea, button, video',
              lastClickTime: n.now(),
              clickTimeout: void 0,
              velocities: [],
              allowMomentumBounce: void 0,
              isTouchEvent: void 0,
              startMoving: void 0,
            },
            allowClick: !0,
            allowTouchMove: h.params.allowTouchMove,
            touches: {
              startX: 0,
              startY: 0,
              currentX: 0,
              currentY: 0,
              diff: 0,
            },
            imagesToLoad: [],
            imagesLoaded: 0,
          }),
          h.useModules(),
          h.params.init && h.init(),
          h
        )
      }
    }
    e && (t.__proto__ = e),
      (t.prototype = Object.create(e && e.prototype)),
      (t.prototype.constructor = t)
    const i = {
      extendedDefaults: { configurable: !0 },
      defaults: { configurable: !0 },
      Class: { configurable: !0 },
      $: { configurable: !0 },
    }
    return (
      (t.prototype.slidesPerViewDynamic = function () {
        const e = this.params
        const t = this.slides
        const i = this.slidesGrid
        const s = this.size
        const a = this.activeIndex
        let r = 1
        if (e.centeredSlides) {
          for (var n, o = t[a].swiperSlideSize, l = a + 1; l < t.length; l += 1)
            t[l] &&
              !n &&
              ((r += 1), (o += t[l].swiperSlideSize) > s && (n = !0))
          for (let d = a - 1; d >= 0; d -= 1)
            t[d] &&
              !n &&
              ((r += 1), (o += t[d].swiperSlideSize) > s && (n = !0))
        } else
          for (let h = a + 1; h < t.length; h += 1) i[h] - i[a] < s && (r += 1)
        return r
      }),
      (t.prototype.update = function () {
        const e = this
        if (e && !e.destroyed) {
          const t = e.snapGrid
          const i = e.params
          i.breakpoints && e.setBreakpoint(),
            e.updateSize(),
            e.updateSlides(),
            e.updateProgress(),
            e.updateSlidesClasses(),
            e.params.freeMode
              ? (s(), e.params.autoHeight && e.updateAutoHeight())
              : ((e.params.slidesPerView === 'auto' ||
                  e.params.slidesPerView > 1) &&
                e.isEnd &&
                !e.params.centeredSlides
                  ? e.slideTo(e.slides.length - 1, 0, !1, !0)
                  : e.slideTo(e.activeIndex, 0, !1, !0)) || s(),
            i.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
            e.emit('update')
        }
        function s() {
          const t = e.rtlTranslate ? -1 * e.translate : e.translate
          const i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate())
          e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses()
        }
      }),
      (t.prototype.changeDirection = function (e, t) {
        void 0 === t && (t = !0)
        const i = this.params.direction
        return (
          e || (e = i === 'horizontal' ? 'vertical' : 'horizontal'),
          e === i || (e !== 'horizontal' && e !== 'vertical')
            ? this
            : (this.$el
                .removeClass('' + this.params.containerModifierClass + i)
                .addClass('' + this.params.containerModifierClass + e),
              (this.params.direction = e),
              this.slides.each(function (t, i) {
                e === 'vertical' ? (i.style.width = '') : (i.style.height = '')
              }),
              this.emit('changeDirection'),
              t && this.update(),
              this)
        )
      }),
      (t.prototype.init = function () {
        this.initialized ||
          (this.emit('beforeInit'),
          this.params.breakpoints && this.setBreakpoint(),
          this.addClasses(),
          this.params.loop && this.loopCreate(),
          this.updateSize(),
          this.updateSlides(),
          this.params.watchOverflow && this.checkOverflow(),
          this.params.grabCursor && this.setGrabCursor(),
          this.params.preloadImages && this.preloadImages(),
          this.params.loop
            ? this.slideTo(
                this.params.initialSlide + this.loopedSlides,
                0,
                this.params.runCallbacksOnInit
              )
            : this.slideTo(
                this.params.initialSlide,
                0,
                this.params.runCallbacksOnInit
              ),
          this.attachEvents(),
          (this.initialized = !0),
          this.emit('init'))
      }),
      (t.prototype.destroy = function (e, t) {
        void 0 === e && (e = !0), void 0 === t && (t = !0)
        const i = this
        const s = i.params
        const a = i.$el
        const r = i.$wrapperEl
        const o = i.slides
        return void 0 === i.params || i.destroyed
          ? null
          : (i.emit('beforeDestroy'),
            (i.initialized = !1),
            i.detachEvents(),
            s.loop && i.loopDestroy(),
            t &&
              (i.removeClasses(),
              a.removeAttr('style'),
              r.removeAttr('style'),
              o &&
                o.length &&
                o
                  .removeClass(
                    [
                      s.slideVisibleClass,
                      s.slideActiveClass,
                      s.slideNextClass,
                      s.slidePrevClass,
                    ].join(' ')
                  )
                  .removeAttr('style')
                  .removeAttr('data-swiper-slide-index')),
            i.emit('destroy'),
            Object.keys(i.eventsListeners).forEach(function (e) {
              i.off(e)
            }),
            !1 !== e &&
              ((i.$el[0].swiper = null),
              i.$el.data('swiper', null),
              n.deleteProps(i)),
            (i.destroyed = !0),
            null)
      }),
      (t.extendDefaults = function (e) {
        n.extend(F, e)
      }),
      (i.extendedDefaults.get = function () {
        return F
      }),
      (i.defaults.get = function () {
        return V
      }),
      (i.Class.get = function () {
        return e
      }),
      (i.$.get = function () {
        return s
      }),
      Object.defineProperties(t, i),
      t
    )
  })(l)
  const R = { name: 'device', proto: { device: I }, static: { device: I } }
  const q = { name: 'support', proto: { support: o }, static: { support: o } }
  const j = {
    isEdge: !!t.navigator.userAgent.match(/Edge/g),
    isSafari: (function () {
      const e = t.navigator.userAgent.toLowerCase()
      return (
        e.includes('safari') && !e.includes('chrome') && !e.includes('android')
      )
    })(),
    isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
      t.navigator.userAgent
    ),
  }
  const K = { name: 'browser', proto: { browser: j }, static: { browser: j } }
  const U = {
    name: 'resize',
    create() {
      const e = this
      n.extend(e, {
        resize: {
          resizeHandler() {
            e &&
              !e.destroyed &&
              e.initialized &&
              (e.emit('beforeResize'), e.emit('resize'))
          },
          orientationChangeHandler() {
            e && !e.destroyed && e.initialized && e.emit('orientationchange')
          },
        },
      })
    },
    on: {
      init() {
        t.addEventListener('resize', this.resize.resizeHandler),
          t.addEventListener(
            'orientationchange',
            this.resize.orientationChangeHandler
          )
      },
      destroy() {
        t.removeEventListener('resize', this.resize.resizeHandler),
          t.removeEventListener(
            'orientationchange',
            this.resize.orientationChangeHandler
          )
      },
    },
  }
  var _ = {
    func: t.MutationObserver || t.WebkitMutationObserver,
    attach(e, i) {
      void 0 === i && (i = {})
      const s = this
      const a = new (0, _.func)(function (e) {
        if (e.length !== 1) {
          const i = function () {
            s.emit('observerUpdate', e[0])
          }
          t.requestAnimationFrame
            ? t.requestAnimationFrame(i)
            : t.setTimeout(i, 0)
        } else s.emit('observerUpdate', e[0])
      })
      a.observe(e, {
        attributes: void 0 === i.attributes || i.attributes,
        childList: void 0 === i.childList || i.childList,
        characterData: void 0 === i.characterData || i.characterData,
      }),
        s.observer.observers.push(a)
    },
    init() {
      if (o.observer && this.params.observer) {
        if (this.params.observeParents)
          for (let e = this.$el.parents(), t = 0; t < e.length; t += 1)
            this.observer.attach(e[t])
        this.observer.attach(this.$el[0], {
          childList: this.params.observeSlideChildren,
        }),
          this.observer.attach(this.$wrapperEl[0], { attributes: !1 })
      }
    },
    destroy() {
      this.observer.observers.forEach(function (e) {
        e.disconnect()
      }),
        (this.observer.observers = [])
    },
  }
  const Z = {
    name: 'observer',
    params: { observer: !1, observeParents: !1, observeSlideChildren: !1 },
    create() {
      n.extend(this, {
        observer: {
          init: _.init.bind(this),
          attach: _.attach.bind(this),
          destroy: _.destroy.bind(this),
          observers: [],
        },
      })
    },
    on: {
      init() {
        this.observer.init()
      },
      destroy() {
        this.observer.destroy()
      },
    },
  }
  const Q = {
    update(e) {
      const t = this
      const i = t.params
      const s = i.slidesPerView
      const a = i.slidesPerGroup
      const r = i.centeredSlides
      const o = t.params.virtual
      const l = o.addSlidesBefore
      const d = o.addSlidesAfter
      const h = t.virtual
      const p = h.from
      const c = h.to
      const u = h.slides
      const v = h.slidesGrid
      const f = h.renderSlide
      const m = h.offset
      t.updateActiveIndex()
      let g
      let b
      let w
      const y = t.activeIndex || 0
      ;(g = t.rtlTranslate ? 'right' : t.isHorizontal() ? 'left' : 'top'),
        r
          ? ((b = Math.floor(s / 2) + a + l), (w = Math.floor(s / 2) + a + d))
          : ((b = s + (a - 1) + l), (w = a + d))
      const x = Math.max((y || 0) - w, 0)
      const T = Math.min((y || 0) + b, u.length - 1)
      const E = (t.slidesGrid[x] || 0) - (t.slidesGrid[0] || 0)
      function C() {
        t.updateSlides(),
          t.updateProgress(),
          t.updateSlidesClasses(),
          t.lazy && t.params.lazy.enabled && t.lazy.load()
      }
      if (
        (n.extend(t.virtual, {
          from: x,
          to: T,
          offset: E,
          slidesGrid: t.slidesGrid,
        }),
        p === x && c === T && !e)
      )
        return (
          t.slidesGrid !== v && E !== m && t.slides.css(g, E + 'px'),
          void t.updateProgress()
        )
      if (t.params.virtual.renderExternal)
        return (
          t.params.virtual.renderExternal.call(t, {
            offset: E,
            from: x,
            to: T,
            slides: (function () {
              for (var e = [], t = x; t <= T; t += 1) e.push(u[t])
              return e
            })(),
          }),
          void C()
        )
      const S = []
      const M = []
      if (e) t.$wrapperEl.find('.' + t.params.slideClass).remove()
      else
        for (let P = p; P <= c; P += 1)
          (P < x || P > T) &&
            t.$wrapperEl
              .find(
                '.' +
                  t.params.slideClass +
                  '[data-swiper-slide-index="' +
                  P +
                  '"]'
              )
              .remove()
      for (let z = 0; z < u.length; z += 1)
        z >= x &&
          z <= T &&
          (void 0 === c || e
            ? M.push(z)
            : (z > c && M.push(z), z < p && S.push(z)))
      M.forEach(function (e) {
        t.$wrapperEl.append(f(u[e], e))
      }),
        S.sort(function (e, t) {
          return t - e
        }).forEach(function (e) {
          t.$wrapperEl.prepend(f(u[e], e))
        }),
        t.$wrapperEl.children('.swiper-slide').css(g, E + 'px'),
        C()
    },
    renderSlide(e, t) {
      const i = this.params.virtual
      if (i.cache && this.virtual.cache[t]) return this.virtual.cache[t]
      const a = i.renderSlide
        ? s(i.renderSlide.call(this, e, t))
        : s(
            '<div class="' +
              this.params.slideClass +
              '" data-swiper-slide-index="' +
              t +
              '">' +
              e +
              '</div>'
          )
      return (
        a.attr('data-swiper-slide-index') ||
          a.attr('data-swiper-slide-index', t),
        i.cache && (this.virtual.cache[t] = a),
        a
      )
    },
    appendSlide(e) {
      if (typeof e === 'object' && 'length' in e)
        for (let t = 0; t < e.length; t += 1)
          e[t] && this.virtual.slides.push(e[t])
      else this.virtual.slides.push(e)
      this.virtual.update(!0)
    },
    prependSlide(e) {
      const t = this.activeIndex
      let i = t + 1
      let s = 1
      if (Array.isArray(e)) {
        for (let a = 0; a < e.length; a += 1)
          e[a] && this.virtual.slides.unshift(e[a])
        ;(i = t + e.length), (s = e.length)
      } else this.virtual.slides.unshift(e)
      if (this.params.virtual.cache) {
        const r = this.virtual.cache
        const n = {}
        Object.keys(r).forEach(function (e) {
          const t = r[e]
          const i = t.attr('data-swiper-slide-index')
          i && t.attr('data-swiper-slide-index', parseInt(i, 10) + 1),
            (n[parseInt(e, 10) + s] = t)
        }),
          (this.virtual.cache = n)
      }
      this.virtual.update(!0), this.slideTo(i, 0)
    },
    removeSlide(e) {
      if (e != null) {
        let t = this.activeIndex
        if (Array.isArray(e))
          for (let i = e.length - 1; i >= 0; i -= 1)
            this.virtual.slides.splice(e[i], 1),
              this.params.virtual.cache && delete this.virtual.cache[e[i]],
              e[i] < t && (t -= 1),
              (t = Math.max(t, 0))
        else
          this.virtual.slides.splice(e, 1),
            this.params.virtual.cache && delete this.virtual.cache[e],
            e < t && (t -= 1),
            (t = Math.max(t, 0))
        this.virtual.update(!0), this.slideTo(t, 0)
      }
    },
    removeAllSlides() {
      ;(this.virtual.slides = []),
        this.params.virtual.cache && (this.virtual.cache = {}),
        this.virtual.update(!0),
        this.slideTo(0, 0)
    },
  }
  const J = {
    name: 'virtual',
    params: {
      virtual: {
        enabled: !1,
        slides: [],
        cache: !0,
        renderSlide: null,
        renderExternal: null,
        addSlidesBefore: 0,
        addSlidesAfter: 0,
      },
    },
    create() {
      n.extend(this, {
        virtual: {
          update: Q.update.bind(this),
          appendSlide: Q.appendSlide.bind(this),
          prependSlide: Q.prependSlide.bind(this),
          removeSlide: Q.removeSlide.bind(this),
          removeAllSlides: Q.removeAllSlides.bind(this),
          renderSlide: Q.renderSlide.bind(this),
          slides: this.params.virtual.slides,
          cache: {},
        },
      })
    },
    on: {
      beforeInit() {
        if (this.params.virtual.enabled) {
          this.classNames.push(this.params.containerModifierClass + 'virtual')
          const e = { watchSlidesProgress: !0 }
          n.extend(this.params, e),
            n.extend(this.originalParams, e),
            this.params.initialSlide || this.virtual.update()
        }
      },
      setTranslate() {
        this.params.virtual.enabled && this.virtual.update()
      },
    },
  }
  const ee = {
    handle(i) {
      const s = this.rtlTranslate
      let a = i
      a.originalEvent && (a = a.originalEvent)
      const r = a.keyCode || a.charCode
      if (
        !this.allowSlideNext &&
        ((this.isHorizontal() && r === 39) ||
          (this.isVertical() && r === 40) ||
          r === 34)
      )
        return !1
      if (
        !this.allowSlidePrev &&
        ((this.isHorizontal() && r === 37) ||
          (this.isVertical() && r === 38) ||
          r === 33)
      )
        return !1
      if (
        !(
          a.shiftKey ||
          a.altKey ||
          a.ctrlKey ||
          a.metaKey ||
          (e.activeElement &&
            e.activeElement.nodeName &&
            (e.activeElement.nodeName.toLowerCase() === 'input' ||
              e.activeElement.nodeName.toLowerCase() === 'textarea'))
        )
      ) {
        if (
          this.params.keyboard.onlyInViewport &&
          (r === 33 || r === 34 || r === 37 || r === 39 || r === 38 || r === 40)
        ) {
          let n = !1
          if (
            this.$el.parents('.' + this.params.slideClass).length > 0 &&
            this.$el.parents('.' + this.params.slideActiveClass).length === 0
          )
            return
          const o = t.innerWidth
          const l = t.innerHeight
          const d = this.$el.offset()
          s && (d.left -= this.$el[0].scrollLeft)
          for (
            let h = [
                [d.left, d.top],
                [d.left + this.width, d.top],
                [d.left, d.top + this.height],
                [d.left + this.width, d.top + this.height],
              ],
              p = 0;
            p < h.length;
            p += 1
          ) {
            const c = h[p]
            c[0] >= 0 && c[0] <= o && c[1] >= 0 && c[1] <= l && (n = !0)
          }
          if (!n) return
        }
        this.isHorizontal()
          ? ((r !== 33 && r !== 34 && r !== 37 && r !== 39) ||
              (a.preventDefault ? a.preventDefault() : (a.returnValue = !1)),
            (((r !== 34 && r !== 39) || s) && ((r !== 33 && r !== 37) || !s)) ||
              this.slideNext(),
            (((r !== 33 && r !== 37) || s) && ((r !== 34 && r !== 39) || !s)) ||
              this.slidePrev())
          : ((r !== 33 && r !== 34 && r !== 38 && r !== 40) ||
              (a.preventDefault ? a.preventDefault() : (a.returnValue = !1)),
            (r !== 34 && r !== 40) || this.slideNext(),
            (r !== 33 && r !== 38) || this.slidePrev()),
          this.emit('keyPress', r)
      }
    },
    enable() {
      this.keyboard.enabled ||
        (s(e).on('keydown', this.keyboard.handle), (this.keyboard.enabled = !0))
    },
    disable() {
      this.keyboard.enabled &&
        (s(e).off('keydown', this.keyboard.handle),
        (this.keyboard.enabled = !1))
    },
  }
  const te = {
    name: 'keyboard',
    params: { keyboard: { enabled: !1, onlyInViewport: !0 } },
    create() {
      n.extend(this, {
        keyboard: {
          enabled: !1,
          enable: ee.enable.bind(this),
          disable: ee.disable.bind(this),
          handle: ee.handle.bind(this),
        },
      })
    },
    on: {
      init() {
        this.params.keyboard.enabled && this.keyboard.enable()
      },
      destroy() {
        this.keyboard.enabled && this.keyboard.disable()
      },
    },
  }
  var ie = {
    lastScrollTime: n.now(),
    lastEventBeforeSnap: void 0,
    recentWheelEvents: [],
    event() {
      return t.navigator.userAgent.includes('firefox')
        ? 'DOMMouseScroll'
        : (function () {
            let t = 'onwheel' in e
            if (!t) {
              const i = e.createElement('div')
              i.setAttribute('onwheel', 'return;'),
                (t = typeof i.onwheel === 'function')
            }
            return (
              !t &&
                e.implementation &&
                e.implementation.hasFeature &&
                !0 !== e.implementation.hasFeature('', '') &&
                (t = e.implementation.hasFeature('Events.wheel', '3.0')),
              t
            )
          })()
        ? 'wheel'
        : 'mousewheel'
    },
    normalize(e) {
      let t = 0
      let i = 0
      let s = 0
      let a = 0
      return (
        'detail' in e && (i = e.detail),
        'wheelDelta' in e && (i = -e.wheelDelta / 120),
        'wheelDeltaY' in e && (i = -e.wheelDeltaY / 120),
        'wheelDeltaX' in e && (t = -e.wheelDeltaX / 120),
        'axis' in e && e.axis === e.HORIZONTAL_AXIS && ((t = i), (i = 0)),
        (s = 10 * t),
        (a = 10 * i),
        'deltaY' in e && (a = e.deltaY),
        'deltaX' in e && (s = e.deltaX),
        e.shiftKey && !s && ((s = a), (a = 0)),
        (s || a) &&
          e.deltaMode &&
          (e.deltaMode === 1
            ? ((s *= 40), (a *= 40))
            : ((s *= 800), (a *= 800))),
        s && !t && (t = s < 1 ? -1 : 1),
        a && !i && (i = a < 1 ? -1 : 1),
        { spinX: t, spinY: i, pixelX: s, pixelY: a }
      )
    },
    handleMouseEnter() {
      this.mouseEntered = !0
    },
    handleMouseLeave() {
      this.mouseEntered = !1
    },
    handle(e) {
      let i = e
      const s = this
      const a = s.params.mousewheel
      if (
        (s.params.cssMode && i.preventDefault(),
        !s.mouseEntered && !a.releaseOnEdges)
      )
        return !0
      i.originalEvent && (i = i.originalEvent)
      let r = 0
      const o = s.rtlTranslate ? -1 : 1
      const l = ie.normalize(i)
      if (a.forceToAxis)
        if (s.isHorizontal()) {
          if (!(Math.abs(l.pixelX) > Math.abs(l.pixelY))) return !0
          r = l.pixelX * o
        } else {
          if (!(Math.abs(l.pixelY) > Math.abs(l.pixelX))) return !0
          r = l.pixelY
        }
      else
        r = Math.abs(l.pixelX) > Math.abs(l.pixelY) ? -l.pixelX * o : -l.pixelY
      if (r === 0) return !0
      if ((a.invert && (r = -r), s.params.freeMode)) {
        const d = {
          time: n.now(),
          delta: Math.abs(r),
          direction: Math.sign(r),
        }
        const h = s.mousewheel.lastEventBeforeSnap
        const p =
          h &&
          d.time < h.time + 500 &&
          d.delta <= h.delta &&
          d.direction === h.direction
        if (!p) {
          ;(s.mousewheel.lastEventBeforeSnap = void 0),
            s.params.loop && s.loopFix()
          let c = s.getTranslate() + r * a.sensitivity
          const u = s.isBeginning
          const v = s.isEnd
          if (
            (c >= s.minTranslate() && (c = s.minTranslate()),
            c <= s.maxTranslate() && (c = s.maxTranslate()),
            s.setTransition(0),
            s.setTranslate(c),
            s.updateProgress(),
            s.updateActiveIndex(),
            s.updateSlidesClasses(),
            ((!u && s.isBeginning) || (!v && s.isEnd)) &&
              s.updateSlidesClasses(),
            s.params.freeModeSticky)
          ) {
            clearTimeout(s.mousewheel.timeout), (s.mousewheel.timeout = void 0)
            const f = s.mousewheel.recentWheelEvents
            f.length >= 15 && f.shift()
            const m = f.length ? f[f.length - 1] : void 0
            const g = f[0]
            if (
              (f.push(d),
              m && (d.delta > m.delta || d.direction !== m.direction))
            )
              f.splice(0)
            else if (
              f.length >= 15 &&
              d.time - g.time < 500 &&
              g.delta - d.delta >= 1 &&
              d.delta <= 6
            ) {
              const b = r > 0 ? 0.8 : 0.2
              ;(s.mousewheel.lastEventBeforeSnap = d),
                f.splice(0),
                (s.mousewheel.timeout = n.nextTick(function () {
                  s.slideToClosest(s.params.speed, !0, void 0, b)
                }, 0))
            }
            s.mousewheel.timeout ||
              (s.mousewheel.timeout = n.nextTick(function () {
                ;(s.mousewheel.lastEventBeforeSnap = d),
                  f.splice(0),
                  s.slideToClosest(s.params.speed, !0, void 0, 0.5)
              }, 500))
          }
          if (
            (p || s.emit('scroll', i),
            s.params.autoplay &&
              s.params.autoplayDisableOnInteraction &&
              s.autoplay.stop(),
            c === s.minTranslate() || c === s.maxTranslate())
          )
            return !0
        }
      } else {
        if (n.now() - s.mousewheel.lastScrollTime > 60)
          if (r < 0)
            if ((s.isEnd && !s.params.loop) || s.animating) {
              if (a.releaseOnEdges) return !0
            } else s.slideNext(), s.emit('scroll', i)
          else if ((s.isBeginning && !s.params.loop) || s.animating) {
            if (a.releaseOnEdges) return !0
          } else s.slidePrev(), s.emit('scroll', i)
        s.mousewheel.lastScrollTime = new t.Date().getTime()
      }
      return i.preventDefault ? i.preventDefault() : (i.returnValue = !1), !1
    },
    enable() {
      const e = ie.event()
      if (this.params.cssMode)
        return this.wrapperEl.removeEventListener(e, this.mousewheel.handle), !0
      if (!e) return !1
      if (this.mousewheel.enabled) return !1
      let t = this.$el
      return (
        this.params.mousewheel.eventsTarged !== 'container' &&
          (t = s(this.params.mousewheel.eventsTarged)),
        t.on('mouseenter', this.mousewheel.handleMouseEnter),
        t.on('mouseleave', this.mousewheel.handleMouseLeave),
        t.on(e, this.mousewheel.handle),
        (this.mousewheel.enabled = !0),
        !0
      )
    },
    disable() {
      const e = ie.event()
      if (this.params.cssMode)
        return this.wrapperEl.addEventListener(e, this.mousewheel.handle), !0
      if (!e) return !1
      if (!this.mousewheel.enabled) return !1
      let t = this.$el
      return (
        this.params.mousewheel.eventsTarged !== 'container' &&
          (t = s(this.params.mousewheel.eventsTarged)),
        t.off(e, this.mousewheel.handle),
        (this.mousewheel.enabled = !1),
        !0
      )
    },
  }
  const se = {
    update() {
      const e = this.params.navigation
      if (!this.params.loop) {
        const t = this.navigation
        const i = t.$nextEl
        const s = t.$prevEl
        s &&
          s.length > 0 &&
          (this.isBeginning
            ? s.addClass(e.disabledClass)
            : s.removeClass(e.disabledClass),
          s[
            this.params.watchOverflow && this.isLocked
              ? 'addClass'
              : 'removeClass'
          ](e.lockClass)),
          i &&
            i.length > 0 &&
            (this.isEnd
              ? i.addClass(e.disabledClass)
              : i.removeClass(e.disabledClass),
            i[
              this.params.watchOverflow && this.isLocked
                ? 'addClass'
                : 'removeClass'
            ](e.lockClass))
      }
    },
    onPrevClick(e) {
      e.preventDefault(),
        (this.isBeginning && !this.params.loop) || this.slidePrev()
    },
    onNextClick(e) {
      e.preventDefault(), (this.isEnd && !this.params.loop) || this.slideNext()
    },
    init() {
      let e
      let t
      const i = this.params.navigation
      ;(i.nextEl || i.prevEl) &&
        (i.nextEl &&
          ((e = s(i.nextEl)),
          this.params.uniqueNavElements &&
            typeof i.nextEl === 'string' &&
            e.length > 1 &&
            this.$el.find(i.nextEl).length === 1 &&
            (e = this.$el.find(i.nextEl))),
        i.prevEl &&
          ((t = s(i.prevEl)),
          this.params.uniqueNavElements &&
            typeof i.prevEl === 'string' &&
            t.length > 1 &&
            this.$el.find(i.prevEl).length === 1 &&
            (t = this.$el.find(i.prevEl))),
        e && e.length > 0 && e.on('click', this.navigation.onNextClick),
        t && t.length > 0 && t.on('click', this.navigation.onPrevClick),
        n.extend(this.navigation, {
          $nextEl: e,
          nextEl: e && e[0],
          $prevEl: t,
          prevEl: t && t[0],
        }))
    },
    destroy() {
      const e = this.navigation
      const t = e.$nextEl
      const i = e.$prevEl
      t &&
        t.length &&
        (t.off('click', this.navigation.onNextClick),
        t.removeClass(this.params.navigation.disabledClass)),
        i &&
          i.length &&
          (i.off('click', this.navigation.onPrevClick),
          i.removeClass(this.params.navigation.disabledClass))
    },
  }
  const ae = {
    update() {
      const e = this.rtl
      const t = this.params.pagination
      if (
        t.el &&
        this.pagination.el &&
        this.pagination.$el &&
        this.pagination.$el.length !== 0
      ) {
        let i
        const a =
          this.virtual && this.params.virtual.enabled
            ? this.virtual.slides.length
            : this.slides.length
        const r = this.pagination.$el
        const n = this.params.loop
          ? Math.ceil((a - 2 * this.loopedSlides) / this.params.slidesPerGroup)
          : this.snapGrid.length
        if (
          (this.params.loop
            ? ((i = Math.ceil(
                (this.activeIndex - this.loopedSlides) /
                  this.params.slidesPerGroup
              )) >
                a - 1 - 2 * this.loopedSlides &&
                (i -= a - 2 * this.loopedSlides),
              i > n - 1 && (i -= n),
              i < 0 && this.params.paginationType !== 'bullets' && (i = n + i))
            : (i =
                void 0 !== this.snapIndex
                  ? this.snapIndex
                  : this.activeIndex || 0),
          t.type === 'bullets' &&
            this.pagination.bullets &&
            this.pagination.bullets.length > 0)
        ) {
          let o
          let l
          let d
          const h = this.pagination.bullets
          if (
            (t.dynamicBullets &&
              ((this.pagination.bulletSize = h
                .eq(0)
                [this.isHorizontal() ? 'outerWidth' : 'outerHeight'](!0)),
              r.css(
                this.isHorizontal() ? 'width' : 'height',
                this.pagination.bulletSize * (t.dynamicMainBullets + 4) + 'px'
              ),
              t.dynamicMainBullets > 1 &&
                void 0 !== this.previousIndex &&
                ((this.pagination.dynamicBulletIndex += i - this.previousIndex),
                this.pagination.dynamicBulletIndex > t.dynamicMainBullets - 1
                  ? (this.pagination.dynamicBulletIndex =
                      t.dynamicMainBullets - 1)
                  : this.pagination.dynamicBulletIndex < 0 &&
                    (this.pagination.dynamicBulletIndex = 0)),
              (o = i - this.pagination.dynamicBulletIndex),
              (d =
                ((l = o + (Math.min(h.length, t.dynamicMainBullets) - 1)) + o) /
                2)),
            h.removeClass(
              t.bulletActiveClass +
                ' ' +
                t.bulletActiveClass +
                '-next ' +
                t.bulletActiveClass +
                '-next-next ' +
                t.bulletActiveClass +
                '-prev ' +
                t.bulletActiveClass +
                '-prev-prev ' +
                t.bulletActiveClass +
                '-main'
            ),
            r.length > 1)
          )
            h.each(function (e, a) {
              const r = s(a)
              const n = r.index()
              n === i && r.addClass(t.bulletActiveClass),
                t.dynamicBullets &&
                  (n >= o &&
                    n <= l &&
                    r.addClass(t.bulletActiveClass + '-main'),
                  n === o &&
                    r
                      .prev()
                      .addClass(t.bulletActiveClass + '-prev')
                      .prev()
                      .addClass(t.bulletActiveClass + '-prev-prev'),
                  n === l &&
                    r
                      .next()
                      .addClass(t.bulletActiveClass + '-next')
                      .next()
                      .addClass(t.bulletActiveClass + '-next-next'))
            })
          else {
            const p = h.eq(i)
            const c = p.index()
            if ((p.addClass(t.bulletActiveClass), t.dynamicBullets)) {
              for (var u = h.eq(o), v = h.eq(l), f = o; f <= l; f += 1)
                h.eq(f).addClass(t.bulletActiveClass + '-main')
              if (this.params.loop)
                if (c >= h.length - t.dynamicMainBullets) {
                  for (let m = t.dynamicMainBullets; m >= 0; m -= 1)
                    h.eq(h.length - m).addClass(t.bulletActiveClass + '-main')
                  h.eq(h.length - t.dynamicMainBullets - 1).addClass(
                    t.bulletActiveClass + '-prev'
                  )
                } else
                  u
                    .prev()
                    .addClass(t.bulletActiveClass + '-prev')
                    .prev()
                    .addClass(t.bulletActiveClass + '-prev-prev'),
                    v
                      .next()
                      .addClass(t.bulletActiveClass + '-next')
                      .next()
                      .addClass(t.bulletActiveClass + '-next-next')
              else
                u
                  .prev()
                  .addClass(t.bulletActiveClass + '-prev')
                  .prev()
                  .addClass(t.bulletActiveClass + '-prev-prev'),
                  v
                    .next()
                    .addClass(t.bulletActiveClass + '-next')
                    .next()
                    .addClass(t.bulletActiveClass + '-next-next')
            }
          }
          if (t.dynamicBullets) {
            const g = Math.min(h.length, t.dynamicMainBullets + 4)
            const b =
              (this.pagination.bulletSize * g - this.pagination.bulletSize) /
                2 -
              d * this.pagination.bulletSize
            const w = e ? 'right' : 'left'
            h.css(this.isHorizontal() ? w : 'top', b + 'px')
          }
        }
        if (
          (t.type === 'fraction' &&
            (r.find('.' + t.currentClass).text(t.formatFractionCurrent(i + 1)),
            r.find('.' + t.totalClass).text(t.formatFractionTotal(n))),
          t.type === 'progressbar')
        ) {
          let y
          y = t.progressbarOpposite
            ? this.isHorizontal()
              ? 'vertical'
              : 'horizontal'
            : this.isHorizontal()
            ? 'horizontal'
            : 'vertical'
          const x = (i + 1) / n
          let T = 1
          let E = 1
          y === 'horizontal' ? (T = x) : (E = x),
            r
              .find('.' + t.progressbarFillClass)
              .transform(
                'translate3d(0,0,0) scaleX(' + T + ') scaleY(' + E + ')'
              )
              .transition(this.params.speed)
        }
        t.type === 'custom' && t.renderCustom
          ? (r.html(t.renderCustom(this, i + 1, n)),
            this.emit('paginationRender', this, r[0]))
          : this.emit('paginationUpdate', this, r[0]),
          r[
            this.params.watchOverflow && this.isLocked
              ? 'addClass'
              : 'removeClass'
          ](t.lockClass)
      }
    },
    render() {
      const e = this.params.pagination
      if (
        e.el &&
        this.pagination.el &&
        this.pagination.$el &&
        this.pagination.$el.length !== 0
      ) {
        const t =
          this.virtual && this.params.virtual.enabled
            ? this.virtual.slides.length
            : this.slides.length
        const i = this.pagination.$el
        let s = ''
        if (e.type === 'bullets') {
          for (
            let a = this.params.loop
                ? Math.ceil(
                    (t - 2 * this.loopedSlides) / this.params.slidesPerGroup
                  )
                : this.snapGrid.length,
              r = 0;
            r < a;
            r += 1
          )
            e.renderBullet
              ? (s += e.renderBullet.call(this, r, e.bulletClass))
              : (s +=
                  '<' +
                  e.bulletElement +
                  ' class="' +
                  e.bulletClass +
                  '"></' +
                  e.bulletElement +
                  '>')
          i.html(s), (this.pagination.bullets = i.find('.' + e.bulletClass))
        }
        e.type === 'fraction' &&
          ((s = e.renderFraction
            ? e.renderFraction.call(this, e.currentClass, e.totalClass)
            : '<span class="' +
              e.currentClass +
              '"></span> / <span class="' +
              e.totalClass +
              '"></span>'),
          i.html(s)),
          e.type === 'progressbar' &&
            ((s = e.renderProgressbar
              ? e.renderProgressbar.call(this, e.progressbarFillClass)
              : '<span class="' + e.progressbarFillClass + '"></span>'),
            i.html(s)),
          e.type !== 'custom' &&
            this.emit('paginationRender', this.pagination.$el[0])
      }
    },
    init() {
      const e = this
      const t = e.params.pagination
      if (t.el) {
        let i = s(t.el)
        i.length !== 0 &&
          (e.params.uniqueNavElements &&
            typeof t.el === 'string' &&
            i.length > 1 &&
            e.$el.find(t.el).length === 1 &&
            (i = e.$el.find(t.el)),
          t.type === 'bullets' && t.clickable && i.addClass(t.clickableClass),
          i.addClass(t.modifierClass + t.type),
          t.type === 'bullets' &&
            t.dynamicBullets &&
            (i.addClass('' + t.modifierClass + t.type + '-dynamic'),
            (e.pagination.dynamicBulletIndex = 0),
            t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)),
          t.type === 'progressbar' &&
            t.progressbarOpposite &&
            i.addClass(t.progressbarOppositeClass),
          t.clickable &&
            i.on('click', '.' + t.bulletClass, function (t) {
              t.preventDefault()
              let i = s(this).index() * e.params.slidesPerGroup
              e.params.loop && (i += e.loopedSlides), e.slideTo(i)
            }),
          n.extend(e.pagination, { $el: i, el: i[0] }))
      }
    },
    destroy() {
      const e = this.params.pagination
      if (
        e.el &&
        this.pagination.el &&
        this.pagination.$el &&
        this.pagination.$el.length !== 0
      ) {
        const t = this.pagination.$el
        t.removeClass(e.hiddenClass),
          t.removeClass(e.modifierClass + e.type),
          this.pagination.bullets &&
            this.pagination.bullets.removeClass(e.bulletActiveClass),
          e.clickable && t.off('click', '.' + e.bulletClass)
      }
    },
  }
  const re = {
    setTranslate() {
      if (this.params.scrollbar.el && this.scrollbar.el) {
        const e = this.scrollbar
        const t = this.rtlTranslate
        const i = this.progress
        const s = e.dragSize
        const a = e.trackSize
        const r = e.$dragEl
        const n = e.$el
        const o = this.params.scrollbar
        let l = s
        let d = (a - s) * i
        t
          ? (d = -d) > 0
            ? ((l = s - d), (d = 0))
            : -d + s > a && (l = a + d)
          : d < 0
          ? ((l = s + d), (d = 0))
          : d + s > a && (l = a - d),
          this.isHorizontal()
            ? (r.transform('translate3d(' + d + 'px, 0, 0)'),
              (r[0].style.width = l + 'px'))
            : (r.transform('translate3d(0px, ' + d + 'px, 0)'),
              (r[0].style.height = l + 'px')),
          o.hide &&
            (clearTimeout(this.scrollbar.timeout),
            (n[0].style.opacity = 1),
            (this.scrollbar.timeout = setTimeout(function () {
              ;(n[0].style.opacity = 0), n.transition(400)
            }, 1e3)))
      }
    },
    setTransition(e) {
      this.params.scrollbar.el &&
        this.scrollbar.el &&
        this.scrollbar.$dragEl.transition(e)
    },
    updateSize() {
      if (this.params.scrollbar.el && this.scrollbar.el) {
        const e = this.scrollbar
        const t = e.$dragEl
        const i = e.$el
        ;(t[0].style.width = ''), (t[0].style.height = '')
        let s
        const a = this.isHorizontal() ? i[0].offsetWidth : i[0].offsetHeight
        const r = this.size / this.virtualSize
        const o = r * (a / this.size)
        ;(s =
          this.params.scrollbar.dragSize === 'auto'
            ? a * r
            : parseInt(this.params.scrollbar.dragSize, 10)),
          this.isHorizontal()
            ? (t[0].style.width = s + 'px')
            : (t[0].style.height = s + 'px'),
          (i[0].style.display = r >= 1 ? 'none' : ''),
          this.params.scrollbar.hide && (i[0].style.opacity = 0),
          n.extend(e, {
            trackSize: a,
            divider: r,
            moveDivider: o,
            dragSize: s,
          }),
          e.$el[
            this.params.watchOverflow && this.isLocked
              ? 'addClass'
              : 'removeClass'
          ](this.params.scrollbar.lockClass)
      }
    },
    getPointerPosition(e) {
      return this.isHorizontal()
        ? e.type === 'touchstart' || e.type === 'touchmove'
          ? e.targetTouches[0].clientX
          : e.clientX
        : e.type === 'touchstart' || e.type === 'touchmove'
        ? e.targetTouches[0].clientY
        : e.clientY
    },
    setDragPosition(e) {
      let t
      const i = this.scrollbar
      const s = this.rtlTranslate
      const a = i.$el
      const r = i.dragSize
      const n = i.trackSize
      const o = i.dragStartPos
      ;(t =
        (i.getPointerPosition(e) -
          a.offset()[this.isHorizontal() ? 'left' : 'top'] -
          (o !== null ? o : r / 2)) /
        (n - r)),
        (t = Math.max(Math.min(t, 1), 0)),
        s && (t = 1 - t)
      const l =
        this.minTranslate() + (this.maxTranslate() - this.minTranslate()) * t
      this.updateProgress(l),
        this.setTranslate(l),
        this.updateActiveIndex(),
        this.updateSlidesClasses()
    },
    onDragStart(e) {
      const t = this.params.scrollbar
      const i = this.scrollbar
      const s = this.$wrapperEl
      const a = i.$el
      const r = i.$dragEl
      ;(this.scrollbar.isTouched = !0),
        (this.scrollbar.dragStartPos =
          e.target === r[0] || e.target === r
            ? i.getPointerPosition(e) -
              e.target.getBoundingClientRect()[
                this.isHorizontal() ? 'left' : 'top'
              ]
            : null),
        e.preventDefault(),
        e.stopPropagation(),
        s.transition(100),
        r.transition(100),
        i.setDragPosition(e),
        clearTimeout(this.scrollbar.dragTimeout),
        a.transition(0),
        t.hide && a.css('opacity', 1),
        this.params.cssMode && this.$wrapperEl.css('scroll-snap-type', 'none'),
        this.emit('scrollbarDragStart', e)
    },
    onDragMove(e) {
      const t = this.scrollbar
      const i = this.$wrapperEl
      const s = t.$el
      const a = t.$dragEl
      this.scrollbar.isTouched &&
        (e.preventDefault ? e.preventDefault() : (e.returnValue = !1),
        t.setDragPosition(e),
        i.transition(0),
        s.transition(0),
        a.transition(0),
        this.emit('scrollbarDragMove', e))
    },
    onDragEnd(e) {
      const t = this.params.scrollbar
      const i = this.scrollbar
      const s = this.$wrapperEl
      const a = i.$el
      this.scrollbar.isTouched &&
        ((this.scrollbar.isTouched = !1),
        this.params.cssMode &&
          (this.$wrapperEl.css('scroll-snap-type', ''), s.transition('')),
        t.hide &&
          (clearTimeout(this.scrollbar.dragTimeout),
          (this.scrollbar.dragTimeout = n.nextTick(function () {
            a.css('opacity', 0), a.transition(400)
          }, 1e3))),
        this.emit('scrollbarDragEnd', e),
        t.snapOnRelease && this.slideToClosest())
    },
    enableDraggable() {
      if (this.params.scrollbar.el) {
        const t = this.scrollbar
        const i = this.touchEventsTouch
        const s = this.touchEventsDesktop
        const a = this.params
        const r = t.$el[0]
        const n = !(!o.passiveListener || !a.passiveListeners) && {
          passive: !1,
          capture: !1,
        }
        const l = !(!o.passiveListener || !a.passiveListeners) && {
          passive: !0,
          capture: !1,
        }
        o.touch
          ? (r.addEventListener(i.start, this.scrollbar.onDragStart, n),
            r.addEventListener(i.move, this.scrollbar.onDragMove, n),
            r.addEventListener(i.end, this.scrollbar.onDragEnd, l))
          : (r.addEventListener(s.start, this.scrollbar.onDragStart, n),
            e.addEventListener(s.move, this.scrollbar.onDragMove, n),
            e.addEventListener(s.end, this.scrollbar.onDragEnd, l))
      }
    },
    disableDraggable() {
      if (this.params.scrollbar.el) {
        const t = this.scrollbar
        const i = this.touchEventsTouch
        const s = this.touchEventsDesktop
        const a = this.params
        const r = t.$el[0]
        const n = !(!o.passiveListener || !a.passiveListeners) && {
          passive: !1,
          capture: !1,
        }
        const l = !(!o.passiveListener || !a.passiveListeners) && {
          passive: !0,
          capture: !1,
        }
        o.touch
          ? (r.removeEventListener(i.start, this.scrollbar.onDragStart, n),
            r.removeEventListener(i.move, this.scrollbar.onDragMove, n),
            r.removeEventListener(i.end, this.scrollbar.onDragEnd, l))
          : (r.removeEventListener(s.start, this.scrollbar.onDragStart, n),
            e.removeEventListener(s.move, this.scrollbar.onDragMove, n),
            e.removeEventListener(s.end, this.scrollbar.onDragEnd, l))
      }
    },
    init() {
      if (this.params.scrollbar.el) {
        const e = this.scrollbar
        const t = this.$el
        const i = this.params.scrollbar
        let a = s(i.el)
        this.params.uniqueNavElements &&
          typeof i.el === 'string' &&
          a.length > 1 &&
          t.find(i.el).length === 1 &&
          (a = t.find(i.el))
        let r = a.find('.' + this.params.scrollbar.dragClass)
        r.length === 0 &&
          ((r = s(
            '<div class="' + this.params.scrollbar.dragClass + '"></div>'
          )),
          a.append(r)),
          n.extend(e, { $el: a, el: a[0], $dragEl: r, dragEl: r[0] }),
          i.draggable && e.enableDraggable()
      }
    },
    destroy() {
      this.scrollbar.disableDraggable()
    },
  }
  const ne = {
    setTransform(e, t) {
      const i = this.rtl
      const a = s(e)
      const r = i ? -1 : 1
      const n = a.attr('data-swiper-parallax') || '0'
      let o = a.attr('data-swiper-parallax-x')
      let l = a.attr('data-swiper-parallax-y')
      const d = a.attr('data-swiper-parallax-scale')
      const h = a.attr('data-swiper-parallax-opacity')
      if (
        (o || l
          ? ((o = o || '0'), (l = l || '0'))
          : this.isHorizontal()
          ? ((o = n), (l = '0'))
          : ((l = n), (o = '0')),
        (o = o.includes('%')
          ? parseInt(o, 10) * t * r + '%'
          : o * t * r + 'px'),
        (l = l.includes('%') ? parseInt(l, 10) * t + '%' : l * t + 'px'),
        h != null)
      ) {
        const p = h - (h - 1) * (1 - Math.abs(t))
        a[0].style.opacity = p
      }
      if (d == null) a.transform('translate3d(' + o + ', ' + l + ', 0px)')
      else {
        const c = d - (d - 1) * (1 - Math.abs(t))
        a.transform('translate3d(' + o + ', ' + l + ', 0px) scale(' + c + ')')
      }
    },
    setTranslate() {
      const e = this
      const t = e.$el
      const i = e.slides
      const a = e.progress
      const r = e.snapGrid
      t
        .children(
          '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]'
        )
        .each(function (t, i) {
          e.parallax.setTransform(i, a)
        }),
        i.each(function (t, i) {
          let n = i.progress
          e.params.slidesPerGroup > 1 &&
            e.params.slidesPerView !== 'auto' &&
            (n += Math.ceil(t / 2) - a * (r.length - 1)),
            (n = Math.min(Math.max(n, -1), 1)),
            s(i)
              .find(
                '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]'
              )
              .each(function (t, i) {
                e.parallax.setTransform(i, n)
              })
        })
    },
    setTransition(e) {
      void 0 === e && (e = this.params.speed)
      this.$el
        .find(
          '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]'
        )
        .each(function (t, i) {
          const a = s(i)
          let r = parseInt(a.attr('data-swiper-parallax-duration'), 10) || e
          e === 0 && (r = 0), a.transition(r)
        })
    },
  }
  var oe = {
    getDistanceBetweenTouches(e) {
      if (e.targetTouches.length < 2) return 1
      const t = e.targetTouches[0].pageX
      const i = e.targetTouches[0].pageY
      const s = e.targetTouches[1].pageX
      const a = e.targetTouches[1].pageY
      return Math.sqrt(Math.pow(s - t, 2) + Math.pow(a - i, 2))
    },
    onGestureStart(e) {
      const t = this.params.zoom
      const i = this.zoom
      const a = i.gesture
      if (
        ((i.fakeGestureTouched = !1), (i.fakeGestureMoved = !1), !o.gestures)
      ) {
        if (
          e.type !== 'touchstart' ||
          (e.type === 'touchstart' && e.targetTouches.length < 2)
        )
          return
        ;(i.fakeGestureTouched = !0),
          (a.scaleStart = oe.getDistanceBetweenTouches(e))
      }
      ;(a.$slideEl && a.$slideEl.length) ||
      ((a.$slideEl = s(e.target).closest('.swiper-slide')),
      a.$slideEl.length === 0 &&
        (a.$slideEl = this.slides.eq(this.activeIndex)),
      (a.$imageEl = a.$slideEl.find('img, svg, canvas')),
      (a.$imageWrapEl = a.$imageEl.parent('.' + t.containerClass)),
      (a.maxRatio = a.$imageWrapEl.attr('data-swiper-zoom') || t.maxRatio),
      a.$imageWrapEl.length !== 0)
        ? (a.$imageEl.transition(0), (this.zoom.isScaling = !0))
        : (a.$imageEl = void 0)
    },
    onGestureChange(e) {
      const t = this.params.zoom
      const i = this.zoom
      const s = i.gesture
      if (!o.gestures) {
        if (
          e.type !== 'touchmove' ||
          (e.type === 'touchmove' && e.targetTouches.length < 2)
        )
          return
        ;(i.fakeGestureMoved = !0),
          (s.scaleMove = oe.getDistanceBetweenTouches(e))
      }
      s.$imageEl &&
        s.$imageEl.length !== 0 &&
        (o.gestures
          ? (i.scale = e.scale * i.currentScale)
          : (i.scale = (s.scaleMove / s.scaleStart) * i.currentScale),
        i.scale > s.maxRatio &&
          (i.scale = s.maxRatio - 1 + Math.pow(i.scale - s.maxRatio + 1, 0.5)),
        i.scale < t.minRatio &&
          (i.scale = t.minRatio + 1 - Math.pow(t.minRatio - i.scale + 1, 0.5)),
        s.$imageEl.transform('translate3d(0,0,0) scale(' + i.scale + ')'))
    },
    onGestureEnd(e) {
      const t = this.params.zoom
      const i = this.zoom
      const s = i.gesture
      if (!o.gestures) {
        if (!i.fakeGestureTouched || !i.fakeGestureMoved) return
        if (
          e.type !== 'touchend' ||
          (e.type === 'touchend' && e.changedTouches.length < 2 && !I.android)
        )
          return
        ;(i.fakeGestureTouched = !1), (i.fakeGestureMoved = !1)
      }
      s.$imageEl &&
        s.$imageEl.length !== 0 &&
        ((i.scale = Math.max(Math.min(i.scale, s.maxRatio), t.minRatio)),
        s.$imageEl
          .transition(this.params.speed)
          .transform('translate3d(0,0,0) scale(' + i.scale + ')'),
        (i.currentScale = i.scale),
        (i.isScaling = !1),
        i.scale === 1 && (s.$slideEl = void 0))
    },
    onTouchStart(e) {
      const t = this.zoom
      const i = t.gesture
      const s = t.image
      i.$imageEl &&
        i.$imageEl.length !== 0 &&
        (s.isTouched ||
          (I.android && e.preventDefault(),
          (s.isTouched = !0),
          (s.touchesStart.x =
            e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX),
          (s.touchesStart.y =
            e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY)))
    },
    onTouchMove(e) {
      const t = this.zoom
      const i = t.gesture
      const s = t.image
      const a = t.velocity
      if (
        i.$imageEl &&
        i.$imageEl.length !== 0 &&
        ((this.allowClick = !1), s.isTouched && i.$slideEl)
      ) {
        s.isMoved ||
          ((s.width = i.$imageEl[0].offsetWidth),
          (s.height = i.$imageEl[0].offsetHeight),
          (s.startX = n.getTranslate(i.$imageWrapEl[0], 'x') || 0),
          (s.startY = n.getTranslate(i.$imageWrapEl[0], 'y') || 0),
          (i.slideWidth = i.$slideEl[0].offsetWidth),
          (i.slideHeight = i.$slideEl[0].offsetHeight),
          i.$imageWrapEl.transition(0),
          this.rtl && ((s.startX = -s.startX), (s.startY = -s.startY)))
        const r = s.width * t.scale
        const o = s.height * t.scale
        if (!(r < i.slideWidth && o < i.slideHeight)) {
          if (
            ((s.minX = Math.min(i.slideWidth / 2 - r / 2, 0)),
            (s.maxX = -s.minX),
            (s.minY = Math.min(i.slideHeight / 2 - o / 2, 0)),
            (s.maxY = -s.minY),
            (s.touchesCurrent.x =
              e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX),
            (s.touchesCurrent.y =
              e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY),
            !s.isMoved && !t.isScaling)
          ) {
            if (
              this.isHorizontal() &&
              ((Math.floor(s.minX) === Math.floor(s.startX) &&
                s.touchesCurrent.x < s.touchesStart.x) ||
                (Math.floor(s.maxX) === Math.floor(s.startX) &&
                  s.touchesCurrent.x > s.touchesStart.x))
            )
              return void (s.isTouched = !1)
            if (
              !this.isHorizontal() &&
              ((Math.floor(s.minY) === Math.floor(s.startY) &&
                s.touchesCurrent.y < s.touchesStart.y) ||
                (Math.floor(s.maxY) === Math.floor(s.startY) &&
                  s.touchesCurrent.y > s.touchesStart.y))
            )
              return void (s.isTouched = !1)
          }
          e.preventDefault(),
            e.stopPropagation(),
            (s.isMoved = !0),
            (s.currentX = s.touchesCurrent.x - s.touchesStart.x + s.startX),
            (s.currentY = s.touchesCurrent.y - s.touchesStart.y + s.startY),
            s.currentX < s.minX &&
              (s.currentX =
                s.minX + 1 - Math.pow(s.minX - s.currentX + 1, 0.8)),
            s.currentX > s.maxX &&
              (s.currentX =
                s.maxX - 1 + Math.pow(s.currentX - s.maxX + 1, 0.8)),
            s.currentY < s.minY &&
              (s.currentY =
                s.minY + 1 - Math.pow(s.minY - s.currentY + 1, 0.8)),
            s.currentY > s.maxY &&
              (s.currentY =
                s.maxY - 1 + Math.pow(s.currentY - s.maxY + 1, 0.8)),
            a.prevPositionX || (a.prevPositionX = s.touchesCurrent.x),
            a.prevPositionY || (a.prevPositionY = s.touchesCurrent.y),
            a.prevTime || (a.prevTime = Date.now()),
            (a.x =
              (s.touchesCurrent.x - a.prevPositionX) /
              (Date.now() - a.prevTime) /
              2),
            (a.y =
              (s.touchesCurrent.y - a.prevPositionY) /
              (Date.now() - a.prevTime) /
              2),
            Math.abs(s.touchesCurrent.x - a.prevPositionX) < 2 && (a.x = 0),
            Math.abs(s.touchesCurrent.y - a.prevPositionY) < 2 && (a.y = 0),
            (a.prevPositionX = s.touchesCurrent.x),
            (a.prevPositionY = s.touchesCurrent.y),
            (a.prevTime = Date.now()),
            i.$imageWrapEl.transform(
              'translate3d(' + s.currentX + 'px, ' + s.currentY + 'px,0)'
            )
        }
      }
    },
    onTouchEnd() {
      const e = this.zoom
      const t = e.gesture
      const i = e.image
      const s = e.velocity
      if (t.$imageEl && t.$imageEl.length !== 0) {
        if (!i.isTouched || !i.isMoved)
          return (i.isTouched = !1), void (i.isMoved = !1)
        ;(i.isTouched = !1), (i.isMoved = !1)
        let a = 300
        let r = 300
        const n = s.x * a
        const o = i.currentX + n
        const l = s.y * r
        const d = i.currentY + l
        s.x !== 0 && (a = Math.abs((o - i.currentX) / s.x)),
          s.y !== 0 && (r = Math.abs((d - i.currentY) / s.y))
        const h = Math.max(a, r)
        ;(i.currentX = o), (i.currentY = d)
        const p = i.width * e.scale
        const c = i.height * e.scale
        ;(i.minX = Math.min(t.slideWidth / 2 - p / 2, 0)),
          (i.maxX = -i.minX),
          (i.minY = Math.min(t.slideHeight / 2 - c / 2, 0)),
          (i.maxY = -i.minY),
          (i.currentX = Math.max(Math.min(i.currentX, i.maxX), i.minX)),
          (i.currentY = Math.max(Math.min(i.currentY, i.maxY), i.minY)),
          t.$imageWrapEl
            .transition(h)
            .transform(
              'translate3d(' + i.currentX + 'px, ' + i.currentY + 'px,0)'
            )
      }
    },
    onTransitionEnd() {
      const e = this.zoom
      const t = e.gesture
      t.$slideEl &&
        this.previousIndex !== this.activeIndex &&
        (t.$imageEl.transform('translate3d(0,0,0) scale(1)'),
        t.$imageWrapEl.transform('translate3d(0,0,0)'),
        (e.scale = 1),
        (e.currentScale = 1),
        (t.$slideEl = void 0),
        (t.$imageEl = void 0),
        (t.$imageWrapEl = void 0))
    },
    toggle(e) {
      const t = this.zoom
      t.scale && t.scale !== 1 ? t.out() : t.in(e)
    },
    in(e) {
      let t
      let i
      let a
      let r
      let n
      let o
      let l
      let d
      let h
      let p
      let c
      let u
      let v
      let f
      let m
      let g
      const b = this.zoom
      const w = this.params.zoom
      const y = b.gesture
      const x = b.image
      ;(y.$slideEl ||
        ((y.$slideEl = this.clickedSlide
          ? s(this.clickedSlide)
          : this.slides.eq(this.activeIndex)),
        (y.$imageEl = y.$slideEl.find('img, svg, canvas')),
        (y.$imageWrapEl = y.$imageEl.parent('.' + w.containerClass))),
      y.$imageEl && y.$imageEl.length !== 0) &&
        (y.$slideEl.addClass('' + w.zoomedSlideClass),
        void 0 === x.touchesStart.x && e
          ? ((t = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX),
            (i = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY))
          : ((t = x.touchesStart.x), (i = x.touchesStart.y)),
        (b.scale = y.$imageWrapEl.attr('data-swiper-zoom') || w.maxRatio),
        (b.currentScale =
          y.$imageWrapEl.attr('data-swiper-zoom') || w.maxRatio),
        e
          ? ((m = y.$slideEl[0].offsetWidth),
            (g = y.$slideEl[0].offsetHeight),
            (a = y.$slideEl.offset().left + m / 2 - t),
            (r = y.$slideEl.offset().top + g / 2 - i),
            (l = y.$imageEl[0].offsetWidth),
            (d = y.$imageEl[0].offsetHeight),
            (h = l * b.scale),
            (p = d * b.scale),
            (v = -(c = Math.min(m / 2 - h / 2, 0))),
            (f = -(u = Math.min(g / 2 - p / 2, 0))),
            (n = a * b.scale) < c && (n = c),
            n > v && (n = v),
            (o = r * b.scale) < u && (o = u),
            o > f && (o = f))
          : ((n = 0), (o = 0)),
        y.$imageWrapEl
          .transition(300)
          .transform('translate3d(' + n + 'px, ' + o + 'px,0)'),
        y.$imageEl
          .transition(300)
          .transform('translate3d(0,0,0) scale(' + b.scale + ')'))
    },
    out() {
      const e = this.zoom
      const t = this.params.zoom
      const i = e.gesture
      i.$slideEl ||
        ((i.$slideEl = this.clickedSlide
          ? s(this.clickedSlide)
          : this.slides.eq(this.activeIndex)),
        (i.$imageEl = i.$slideEl.find('img, svg, canvas')),
        (i.$imageWrapEl = i.$imageEl.parent('.' + t.containerClass))),
        i.$imageEl &&
          i.$imageEl.length !== 0 &&
          ((e.scale = 1),
          (e.currentScale = 1),
          i.$imageWrapEl.transition(300).transform('translate3d(0,0,0)'),
          i.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)'),
          i.$slideEl.removeClass('' + t.zoomedSlideClass),
          (i.$slideEl = void 0))
    },
    enable() {
      const e = this.zoom
      if (!e.enabled) {
        e.enabled = !0
        const t = !(
          this.touchEvents.start !== 'touchstart' ||
          !o.passiveListener ||
          !this.params.passiveListeners
        ) && { passive: !0, capture: !1 }
        const i = !o.passiveListener || { passive: !1, capture: !0 }
        o.gestures
          ? (this.$wrapperEl.on(
              'gesturestart',
              '.swiper-slide',
              e.onGestureStart,
              t
            ),
            this.$wrapperEl.on(
              'gesturechange',
              '.swiper-slide',
              e.onGestureChange,
              t
            ),
            this.$wrapperEl.on(
              'gestureend',
              '.swiper-slide',
              e.onGestureEnd,
              t
            ))
          : this.touchEvents.start === 'touchstart' &&
            (this.$wrapperEl.on(
              this.touchEvents.start,
              '.swiper-slide',
              e.onGestureStart,
              t
            ),
            this.$wrapperEl.on(
              this.touchEvents.move,
              '.swiper-slide',
              e.onGestureChange,
              i
            ),
            this.$wrapperEl.on(
              this.touchEvents.end,
              '.swiper-slide',
              e.onGestureEnd,
              t
            ),
            this.touchEvents.cancel &&
              this.$wrapperEl.on(
                this.touchEvents.cancel,
                '.swiper-slide',
                e.onGestureEnd,
                t
              )),
          this.$wrapperEl.on(
            this.touchEvents.move,
            '.' + this.params.zoom.containerClass,
            e.onTouchMove,
            i
          )
      }
    },
    disable() {
      const e = this.zoom
      if (e.enabled) {
        this.zoom.enabled = !1
        const t = !(
          this.touchEvents.start !== 'touchstart' ||
          !o.passiveListener ||
          !this.params.passiveListeners
        ) && { passive: !0, capture: !1 }
        const i = !o.passiveListener || { passive: !1, capture: !0 }
        o.gestures
          ? (this.$wrapperEl.off(
              'gesturestart',
              '.swiper-slide',
              e.onGestureStart,
              t
            ),
            this.$wrapperEl.off(
              'gesturechange',
              '.swiper-slide',
              e.onGestureChange,
              t
            ),
            this.$wrapperEl.off(
              'gestureend',
              '.swiper-slide',
              e.onGestureEnd,
              t
            ))
          : this.touchEvents.start === 'touchstart' &&
            (this.$wrapperEl.off(
              this.touchEvents.start,
              '.swiper-slide',
              e.onGestureStart,
              t
            ),
            this.$wrapperEl.off(
              this.touchEvents.move,
              '.swiper-slide',
              e.onGestureChange,
              i
            ),
            this.$wrapperEl.off(
              this.touchEvents.end,
              '.swiper-slide',
              e.onGestureEnd,
              t
            ),
            this.touchEvents.cancel &&
              this.$wrapperEl.off(
                this.touchEvents.cancel,
                '.swiper-slide',
                e.onGestureEnd,
                t
              )),
          this.$wrapperEl.off(
            this.touchEvents.move,
            '.' + this.params.zoom.containerClass,
            e.onTouchMove,
            i
          )
      }
    },
  }
  const le = {
    loadInSlide(e, t) {
      void 0 === t && (t = !0)
      const i = this
      const a = i.params.lazy
      if (void 0 !== e && i.slides.length !== 0) {
        const r =
          i.virtual && i.params.virtual.enabled
            ? i.$wrapperEl.children(
                '.' +
                  i.params.slideClass +
                  '[data-swiper-slide-index="' +
                  e +
                  '"]'
              )
            : i.slides.eq(e)
        let n = r.find(
          '.' +
            a.elementClass +
            ':not(.' +
            a.loadedClass +
            '):not(.' +
            a.loadingClass +
            ')'
        )
        !r.hasClass(a.elementClass) ||
          r.hasClass(a.loadedClass) ||
          r.hasClass(a.loadingClass) ||
          (n = n.add(r[0])),
          n.length !== 0 &&
            n.each(function (e, n) {
              const o = s(n)
              o.addClass(a.loadingClass)
              const l = o.attr('data-background')
              const d = o.attr('data-src')
              const h = o.attr('data-srcset')
              const p = o.attr('data-sizes')
              i.loadImage(o[0], d || l, h, p, !1, function () {
                if (i != null && i && (!i || i.params) && !i.destroyed) {
                  if (
                    (l
                      ? (o.css('background-image', 'url("' + l + '")'),
                        o.removeAttr('data-background'))
                      : (h &&
                          (o.attr('srcset', h), o.removeAttr('data-srcset')),
                        p && (o.attr('sizes', p), o.removeAttr('data-sizes')),
                        d && (o.attr('src', d), o.removeAttr('data-src'))),
                    o.addClass(a.loadedClass).removeClass(a.loadingClass),
                    r.find('.' + a.preloaderClass).remove(),
                    i.params.loop && t)
                  ) {
                    const e = r.attr('data-swiper-slide-index')
                    if (r.hasClass(i.params.slideDuplicateClass)) {
                      const s = i.$wrapperEl.children(
                        '[data-swiper-slide-index="' +
                          e +
                          '"]:not(.' +
                          i.params.slideDuplicateClass +
                          ')'
                      )
                      i.lazy.loadInSlide(s.index(), !1)
                    } else {
                      const n = i.$wrapperEl.children(
                        '.' +
                          i.params.slideDuplicateClass +
                          '[data-swiper-slide-index="' +
                          e +
                          '"]'
                      )
                      i.lazy.loadInSlide(n.index(), !1)
                    }
                  }
                  i.emit('lazyImageReady', r[0], o[0])
                }
              }),
                i.emit('lazyImageLoad', r[0], o[0])
            })
      }
    },
    load() {
      const e = this
      const t = e.$wrapperEl
      const i = e.params
      const a = e.slides
      const r = e.activeIndex
      const n = e.virtual && i.virtual.enabled
      const o = i.lazy
      let l = i.slidesPerView
      function d(e) {
        if (n) {
          if (
            t.children(
              '.' + i.slideClass + '[data-swiper-slide-index="' + e + '"]'
            ).length
          )
            return !0
        } else if (a[e]) return !0
        return !1
      }
      function h(e) {
        return n ? s(e).attr('data-swiper-slide-index') : s(e).index()
      }
      if (
        (l === 'auto' && (l = 0),
        e.lazy.initialImageLoaded || (e.lazy.initialImageLoaded = !0),
        e.params.watchSlidesVisibility)
      )
        t.children('.' + i.slideVisibleClass).each(function (t, i) {
          const a = n ? s(i).attr('data-swiper-slide-index') : s(i).index()
          e.lazy.loadInSlide(a)
        })
      else if (l > 1)
        for (let p = r; p < r + l; p += 1) d(p) && e.lazy.loadInSlide(p)
      else e.lazy.loadInSlide(r)
      if (o.loadPrevNext)
        if (l > 1 || (o.loadPrevNextAmount && o.loadPrevNextAmount > 1)) {
          for (
            var c = o.loadPrevNextAmount,
              u = l,
              v = Math.min(r + u + Math.max(c, u), a.length),
              f = Math.max(r - Math.max(u, c), 0),
              m = r + l;
            m < v;
            m += 1
          )
            d(m) && e.lazy.loadInSlide(m)
          for (let g = f; g < r; g += 1) d(g) && e.lazy.loadInSlide(g)
        } else {
          const b = t.children('.' + i.slideNextClass)
          b.length > 0 && e.lazy.loadInSlide(h(b))
          const w = t.children('.' + i.slidePrevClass)
          w.length > 0 && e.lazy.loadInSlide(h(w))
        }
    },
  }
  var de = {
    LinearSpline(e, t) {
      let i
      let s
      let a
      let r
      let n
      const o = function (e, t) {
        for (s = -1, i = e.length; i - s > 1; )
          e[(a = (i + s) >> 1)] <= t ? (s = a) : (i = a)
        return i
      }
      return (
        (this.x = e),
        (this.y = t),
        (this.lastIndex = e.length - 1),
        (this.interpolate = function (e) {
          return e
            ? ((n = o(this.x, e)),
              (r = n - 1),
              ((e - this.x[r]) * (this.y[n] - this.y[r])) /
                (this.x[n] - this.x[r]) +
                this.y[r])
            : 0
        }),
        this
      )
    },
    getInterpolateFunction(e) {
      this.controller.spline ||
        (this.controller.spline = this.params.loop
          ? new de.LinearSpline(this.slidesGrid, e.slidesGrid)
          : new de.LinearSpline(this.snapGrid, e.snapGrid))
    },
    setTranslate(e, t) {
      let i
      let s
      const a = this
      const r = a.controller.control
      function n(e) {
        const t = a.rtlTranslate ? -a.translate : a.translate
        a.params.controller.by === 'slide' &&
          (a.controller.getInterpolateFunction(e),
          (s = -a.controller.spline.interpolate(-t))),
          (s && a.params.controller.by !== 'container') ||
            ((i =
              (e.maxTranslate() - e.minTranslate()) /
              (a.maxTranslate() - a.minTranslate())),
            (s = (t - a.minTranslate()) * i + e.minTranslate())),
          a.params.controller.inverse && (s = e.maxTranslate() - s),
          e.updateProgress(s),
          e.setTranslate(s, a),
          e.updateActiveIndex(),
          e.updateSlidesClasses()
      }
      if (Array.isArray(r))
        for (let o = 0; o < r.length; o += 1)
          r[o] !== t && r[o] instanceof W && n(r[o])
      else r instanceof W && t !== r && n(r)
    },
    setTransition(e, t) {
      let i
      const s = this
      const a = s.controller.control
      function r(t) {
        t.setTransition(e, s),
          e !== 0 &&
            (t.transitionStart(),
            t.params.autoHeight &&
              n.nextTick(function () {
                t.updateAutoHeight()
              }),
            t.$wrapperEl.transitionEnd(function () {
              a &&
                (t.params.loop &&
                  s.params.controller.by === 'slide' &&
                  t.loopFix(),
                t.transitionEnd())
            }))
      }
      if (Array.isArray(a))
        for (i = 0; i < a.length; i += 1)
          a[i] !== t && a[i] instanceof W && r(a[i])
      else a instanceof W && t !== a && r(a)
    },
  }
  const he = {
    makeElFocusable(e) {
      return e.attr('tabIndex', '0'), e
    },
    addElRole(e, t) {
      return e.attr('role', t), e
    },
    addElLabel(e, t) {
      return e.attr('aria-label', t), e
    },
    disableEl(e) {
      return e.attr('aria-disabled', !0), e
    },
    enableEl(e) {
      return e.attr('aria-disabled', !1), e
    },
    onEnterKey(e) {
      const t = this.params.a11y
      if (e.keyCode === 13) {
        const i = s(e.target)
        this.navigation &&
          this.navigation.$nextEl &&
          i.is(this.navigation.$nextEl) &&
          ((this.isEnd && !this.params.loop) || this.slideNext(),
          this.isEnd
            ? this.a11y.notify(t.lastSlideMessage)
            : this.a11y.notify(t.nextSlideMessage)),
          this.navigation &&
            this.navigation.$prevEl &&
            i.is(this.navigation.$prevEl) &&
            ((this.isBeginning && !this.params.loop) || this.slidePrev(),
            this.isBeginning
              ? this.a11y.notify(t.firstSlideMessage)
              : this.a11y.notify(t.prevSlideMessage)),
          this.pagination &&
            i.is('.' + this.params.pagination.bulletClass) &&
            i[0].click()
      }
    },
    notify(e) {
      const t = this.a11y.liveRegion
      t.length !== 0 && (t.html(''), t.html(e))
    },
    updateNavigation() {
      if (!this.params.loop) {
        const e = this.navigation
        const t = e.$nextEl
        const i = e.$prevEl
        i &&
          i.length > 0 &&
          (this.isBeginning ? this.a11y.disableEl(i) : this.a11y.enableEl(i)),
          t &&
            t.length > 0 &&
            (this.isEnd ? this.a11y.disableEl(t) : this.a11y.enableEl(t))
      }
    },
    updatePagination() {
      const e = this
      const t = e.params.a11y
      e.pagination &&
        e.params.pagination.clickable &&
        e.pagination.bullets &&
        e.pagination.bullets.length &&
        e.pagination.bullets.each(function (i, a) {
          const r = s(a)
          e.a11y.makeElFocusable(r),
            e.a11y.addElRole(r, 'button'),
            e.a11y.addElLabel(
              r,
              t.paginationBulletMessage.replace(/{{index}}/, r.index() + 1)
            )
        })
    },
    init() {
      this.$el.append(this.a11y.liveRegion)
      let e
      let t
      const i = this.params.a11y
      this.navigation &&
        this.navigation.$nextEl &&
        (e = this.navigation.$nextEl),
        this.navigation &&
          this.navigation.$prevEl &&
          (t = this.navigation.$prevEl),
        e &&
          (this.a11y.makeElFocusable(e),
          this.a11y.addElRole(e, 'button'),
          this.a11y.addElLabel(e, i.nextSlideMessage),
          e.on('keydown', this.a11y.onEnterKey)),
        t &&
          (this.a11y.makeElFocusable(t),
          this.a11y.addElRole(t, 'button'),
          this.a11y.addElLabel(t, i.prevSlideMessage),
          t.on('keydown', this.a11y.onEnterKey)),
        this.pagination &&
          this.params.pagination.clickable &&
          this.pagination.bullets &&
          this.pagination.bullets.length &&
          this.pagination.$el.on(
            'keydown',
            '.' + this.params.pagination.bulletClass,
            this.a11y.onEnterKey
          )
    },
    destroy() {
      let e, t
      this.a11y.liveRegion &&
        this.a11y.liveRegion.length > 0 &&
        this.a11y.liveRegion.remove(),
        this.navigation &&
          this.navigation.$nextEl &&
          (e = this.navigation.$nextEl),
        this.navigation &&
          this.navigation.$prevEl &&
          (t = this.navigation.$prevEl),
        e && e.off('keydown', this.a11y.onEnterKey),
        t && t.off('keydown', this.a11y.onEnterKey),
        this.pagination &&
          this.params.pagination.clickable &&
          this.pagination.bullets &&
          this.pagination.bullets.length &&
          this.pagination.$el.off(
            'keydown',
            '.' + this.params.pagination.bulletClass,
            this.a11y.onEnterKey
          )
    },
  }
  var pe = {
    init() {
      if (this.params.history) {
        if (!t.history || !t.history.pushState)
          return (
            (this.params.history.enabled = !1),
            void (this.params.hashNavigation.enabled = !0)
          )
        const e = this.history
        ;(e.initialized = !0),
          (e.paths = pe.getPathValues()),
          (e.paths.key || e.paths.value) &&
            (e.scrollToSlide(0, e.paths.value, this.params.runCallbacksOnInit),
            this.params.history.replaceState ||
              t.addEventListener('popstate', this.history.setHistoryPopState))
      }
    },
    destroy() {
      this.params.history.replaceState ||
        t.removeEventListener('popstate', this.history.setHistoryPopState)
    },
    setHistoryPopState() {
      ;(this.history.paths = pe.getPathValues()),
        this.history.scrollToSlide(
          this.params.speed,
          this.history.paths.value,
          !1
        )
    },
    getPathValues() {
      const e = t.location.pathname
        .slice(1)
        .split('/')
        .filter(function (e) {
          return e !== ''
        })
      const i = e.length
      return { key: e[i - 2], value: e[i - 1] }
    },
    setHistory(e, i) {
      if (this.history.initialized && this.params.history.enabled) {
        const s = this.slides.eq(i)
        let a = pe.slugify(s.attr('data-history'))
        t.location.pathname.includes(e) || (a = e + '/' + a)
        const r = t.history.state
        ;(r && r.value === a) ||
          (this.params.history.replaceState
            ? t.history.replaceState({ value: a }, null, a)
            : t.history.pushState({ value: a }, null, a))
      }
    },
    slugify(e) {
      return e
        .toString()
        .replace(/\s+/g, '-')
        .replace(/[^\w-]+/g, '')
        .replace(/--+/g, '-')
        .replace(/^-+/, '')
        .replace(/-+$/, '')
    },
    scrollToSlide(e, t, i) {
      if (t)
        for (let s = 0, a = this.slides.length; s < a; s += 1) {
          const r = this.slides.eq(s)
          if (
            pe.slugify(r.attr('data-history')) === t &&
            !r.hasClass(this.params.slideDuplicateClass)
          ) {
            const n = r.index()
            this.slideTo(n, e, i)
          }
        }
      else this.slideTo(0, e, i)
    },
  }
  const ce = {
    onHashCange() {
      const t = e.location.hash.replace('#', '')
      if (t !== this.slides.eq(this.activeIndex).attr('data-hash')) {
        const i = this.$wrapperEl
          .children('.' + this.params.slideClass + '[data-hash="' + t + '"]')
          .index()
        if (void 0 === i) return
        this.slideTo(i)
      }
    },
    setHash() {
      if (this.hashNavigation.initialized && this.params.hashNavigation.enabled)
        if (
          this.params.hashNavigation.replaceState &&
          t.history &&
          t.history.replaceState
        )
          t.history.replaceState(
            null,
            null,
            '#' + this.slides.eq(this.activeIndex).attr('data-hash') || ''
          )
        else {
          const i = this.slides.eq(this.activeIndex)
          const s = i.attr('data-hash') || i.attr('data-history')
          e.location.hash = s || ''
        }
    },
    init() {
      if (
        !(
          !this.params.hashNavigation.enabled ||
          (this.params.history && this.params.history.enabled)
        )
      ) {
        this.hashNavigation.initialized = !0
        const i = e.location.hash.replace('#', '')
        if (i)
          for (let a = 0, r = this.slides.length; a < r; a += 1) {
            const n = this.slides.eq(a)
            if (
              (n.attr('data-hash') || n.attr('data-history')) === i &&
              !n.hasClass(this.params.slideDuplicateClass)
            ) {
              const o = n.index()
              this.slideTo(o, 0, this.params.runCallbacksOnInit, !0)
            }
          }
        this.params.hashNavigation.watchState &&
          s(t).on('hashchange', this.hashNavigation.onHashCange)
      }
    },
    destroy() {
      this.params.hashNavigation.watchState &&
        s(t).off('hashchange', this.hashNavigation.onHashCange)
    },
  }
  const ue = {
    run() {
      const e = this
      const t = e.slides.eq(e.activeIndex)
      let i = e.params.autoplay.delay
      t.attr('data-swiper-autoplay') &&
        (i = t.attr('data-swiper-autoplay') || e.params.autoplay.delay),
        clearTimeout(e.autoplay.timeout),
        (e.autoplay.timeout = n.nextTick(function () {
          e.params.autoplay.reverseDirection
            ? e.params.loop
              ? (e.loopFix(),
                e.slidePrev(e.params.speed, !0, !0),
                e.emit('autoplay'))
              : e.isBeginning
              ? e.params.autoplay.stopOnLastSlide
                ? e.autoplay.stop()
                : (e.slideTo(e.slides.length - 1, e.params.speed, !0, !0),
                  e.emit('autoplay'))
              : (e.slidePrev(e.params.speed, !0, !0), e.emit('autoplay'))
            : e.params.loop
            ? (e.loopFix(),
              e.slideNext(e.params.speed, !0, !0),
              e.emit('autoplay'))
            : e.isEnd
            ? e.params.autoplay.stopOnLastSlide
              ? e.autoplay.stop()
              : (e.slideTo(0, e.params.speed, !0, !0), e.emit('autoplay'))
            : (e.slideNext(e.params.speed, !0, !0), e.emit('autoplay')),
            e.params.cssMode && e.autoplay.running && e.autoplay.run()
        }, i))
    },
    start() {
      return (
        void 0 === this.autoplay.timeout &&
        !this.autoplay.running &&
        ((this.autoplay.running = !0),
        this.emit('autoplayStart'),
        this.autoplay.run(),
        !0)
      )
    },
    stop() {
      return (
        !!this.autoplay.running &&
        void 0 !== this.autoplay.timeout &&
        (this.autoplay.timeout &&
          (clearTimeout(this.autoplay.timeout),
          (this.autoplay.timeout = void 0)),
        (this.autoplay.running = !1),
        this.emit('autoplayStop'),
        !0)
      )
    },
    pause(e) {
      this.autoplay.running &&
        (this.autoplay.paused ||
          (this.autoplay.timeout && clearTimeout(this.autoplay.timeout),
          (this.autoplay.paused = !0),
          e !== 0 && this.params.autoplay.waitForTransition
            ? (this.$wrapperEl[0].addEventListener(
                'transitionend',
                this.autoplay.onTransitionEnd
              ),
              this.$wrapperEl[0].addEventListener(
                'webkitTransitionEnd',
                this.autoplay.onTransitionEnd
              ))
            : ((this.autoplay.paused = !1), this.autoplay.run())))
    },
  }
  const ve = {
    setTranslate() {
      for (let e = this.slides, t = 0; t < e.length; t += 1) {
        const i = this.slides.eq(t)
        let s = -i[0].swiperSlideOffset
        this.params.virtualTranslate || (s -= this.translate)
        let a = 0
        this.isHorizontal() || ((a = s), (s = 0))
        const r = this.params.fadeEffect.crossFade
          ? Math.max(1 - Math.abs(i[0].progress), 0)
          : 1 + Math.min(Math.max(i[0].progress, -1), 0)
        i.css({ opacity: r }).transform(
          'translate3d(' + s + 'px, ' + a + 'px, 0px)'
        )
      }
    },
    setTransition(e) {
      const t = this
      const i = t.slides
      const s = t.$wrapperEl
      if ((i.transition(e), t.params.virtualTranslate && e !== 0)) {
        let a = !1
        i.transitionEnd(function () {
          if (!a && t && !t.destroyed) {
            ;(a = !0), (t.animating = !1)
            for (
              let e = ['webkitTransitionEnd', 'transitionend'], i = 0;
              i < e.length;
              i += 1
            )
              s.trigger(e[i])
          }
        })
      }
    },
  }
  const fe = {
    setTranslate() {
      let e
      const t = this.$el
      const i = this.$wrapperEl
      const a = this.slides
      const r = this.width
      const n = this.height
      const o = this.rtlTranslate
      const l = this.size
      const d = this.params.cubeEffect
      const h = this.isHorizontal()
      const p = this.virtual && this.params.virtual.enabled
      let c = 0
      d.shadow &&
        (h
          ? ((e = i.find('.swiper-cube-shadow')).length === 0 &&
              ((e = s('<div class="swiper-cube-shadow"></div>')), i.append(e)),
            e.css({ height: r + 'px' }))
          : (e = t.find('.swiper-cube-shadow')).length === 0 &&
            ((e = s('<div class="swiper-cube-shadow"></div>')), t.append(e)))
      for (let u = 0; u < a.length; u += 1) {
        const v = a.eq(u)
        let f = u
        p && (f = parseInt(v.attr('data-swiper-slide-index'), 10))
        let m = 90 * f
        let g = Math.floor(m / 360)
        o && ((m = -m), (g = Math.floor(-m / 360)))
        const b = Math.max(Math.min(v[0].progress, 1), -1)
        let w = 0
        let y = 0
        let x = 0
        f % 4 == 0
          ? ((w = 4 * -g * l), (x = 0))
          : (f - 1) % 4 == 0
          ? ((w = 0), (x = 4 * -g * l))
          : (f - 2) % 4 == 0
          ? ((w = l + 4 * g * l), (x = l))
          : (f - 3) % 4 == 0 && ((w = -l), (x = 3 * l + 4 * l * g)),
          o && (w = -w),
          h || ((y = w), (w = 0))
        const T =
          'rotateX(' +
          (h ? 0 : -m) +
          'deg) rotateY(' +
          (h ? m : 0) +
          'deg) translate3d(' +
          w +
          'px, ' +
          y +
          'px, ' +
          x +
          'px)'
        if (
          (b <= 1 &&
            b > -1 &&
            ((c = 90 * f + 90 * b), o && (c = 90 * -f - 90 * b)),
          v.transform(T),
          d.slideShadows)
        ) {
          let E = h
            ? v.find('.swiper-slide-shadow-left')
            : v.find('.swiper-slide-shadow-top')
          let C = h
            ? v.find('.swiper-slide-shadow-right')
            : v.find('.swiper-slide-shadow-bottom')
          E.length === 0 &&
            ((E = s(
              '<div class="swiper-slide-shadow-' +
                (h ? 'left' : 'top') +
                '"></div>'
            )),
            v.append(E)),
            C.length === 0 &&
              ((C = s(
                '<div class="swiper-slide-shadow-' +
                  (h ? 'right' : 'bottom') +
                  '"></div>'
              )),
              v.append(C)),
            E.length && (E[0].style.opacity = Math.max(-b, 0)),
            C.length && (C[0].style.opacity = Math.max(b, 0))
        }
      }
      if (
        (i.css({
          '-webkit-transform-origin': '50% 50% -' + l / 2 + 'px',
          '-moz-transform-origin': '50% 50% -' + l / 2 + 'px',
          '-ms-transform-origin': '50% 50% -' + l / 2 + 'px',
          'transform-origin': '50% 50% -' + l / 2 + 'px',
        }),
        d.shadow)
      )
        if (h)
          e.transform(
            'translate3d(0px, ' +
              (r / 2 + d.shadowOffset) +
              'px, ' +
              -r / 2 +
              'px) rotateX(90deg) rotateZ(0deg) scale(' +
              d.shadowScale +
              ')'
          )
        else {
          const S = Math.abs(c) - 90 * Math.floor(Math.abs(c) / 90)
          const M =
            1.5 -
            (Math.sin((2 * S * Math.PI) / 360) / 2 +
              Math.cos((2 * S * Math.PI) / 360) / 2)
          const P = d.shadowScale
          const z = d.shadowScale / M
          const k = d.shadowOffset
          e.transform(
            'scale3d(' +
              P +
              ', 1, ' +
              z +
              ') translate3d(0px, ' +
              (n / 2 + k) +
              'px, ' +
              -n / 2 / z +
              'px) rotateX(-90deg)'
          )
        }
      const $ = j.isSafari || j.isUiWebView ? -l / 2 : 0
      i.transform(
        'translate3d(0px,0,' +
          $ +
          'px) rotateX(' +
          (this.isHorizontal() ? 0 : c) +
          'deg) rotateY(' +
          (this.isHorizontal() ? -c : 0) +
          'deg)'
      )
    },
    setTransition(e) {
      const t = this.$el
      this.slides
        .transition(e)
        .find(
          '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left'
        )
        .transition(e),
        this.params.cubeEffect.shadow &&
          !this.isHorizontal() &&
          t.find('.swiper-cube-shadow').transition(e)
    },
  }
  const me = {
    setTranslate() {
      for (
        let e = this.slides, t = this.rtlTranslate, i = 0;
        i < e.length;
        i += 1
      ) {
        const a = e.eq(i)
        let r = a[0].progress
        this.params.flipEffect.limitRotation &&
          (r = Math.max(Math.min(a[0].progress, 1), -1))
        let n = -180 * r
        let o = 0
        let l = -a[0].swiperSlideOffset
        let d = 0
        if (
          (this.isHorizontal()
            ? t && (n = -n)
            : ((d = l), (l = 0), (o = -n), (n = 0)),
          (a[0].style.zIndex = -Math.abs(Math.round(r)) + e.length),
          this.params.flipEffect.slideShadows)
        ) {
          let h = this.isHorizontal()
            ? a.find('.swiper-slide-shadow-left')
            : a.find('.swiper-slide-shadow-top')
          let p = this.isHorizontal()
            ? a.find('.swiper-slide-shadow-right')
            : a.find('.swiper-slide-shadow-bottom')
          h.length === 0 &&
            ((h = s(
              '<div class="swiper-slide-shadow-' +
                (this.isHorizontal() ? 'left' : 'top') +
                '"></div>'
            )),
            a.append(h)),
            p.length === 0 &&
              ((p = s(
                '<div class="swiper-slide-shadow-' +
                  (this.isHorizontal() ? 'right' : 'bottom') +
                  '"></div>'
              )),
              a.append(p)),
            h.length && (h[0].style.opacity = Math.max(-r, 0)),
            p.length && (p[0].style.opacity = Math.max(r, 0))
        }
        a.transform(
          'translate3d(' +
            l +
            'px, ' +
            d +
            'px, 0px) rotateX(' +
            o +
            'deg) rotateY(' +
            n +
            'deg)'
        )
      }
    },
    setTransition(e) {
      const t = this
      const i = t.slides
      const s = t.activeIndex
      const a = t.$wrapperEl
      if (
        (i
          .transition(e)
          .find(
            '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left'
          )
          .transition(e),
        t.params.virtualTranslate && e !== 0)
      ) {
        let r = !1
        i.eq(s).transitionEnd(function () {
          if (!r && t && !t.destroyed) {
            ;(r = !0), (t.animating = !1)
            for (
              let e = ['webkitTransitionEnd', 'transitionend'], i = 0;
              i < e.length;
              i += 1
            )
              a.trigger(e[i])
          }
        })
      }
    },
  }
  const ge = {
    setTranslate() {
      for (
        var e = this.width,
          t = this.height,
          i = this.slides,
          a = this.$wrapperEl,
          r = this.slidesSizesGrid,
          n = this.params.coverflowEffect,
          l = this.isHorizontal(),
          d = this.translate,
          h = l ? e / 2 - d : t / 2 - d,
          p = l ? n.rotate : -n.rotate,
          c = n.depth,
          u = 0,
          v = i.length;
        u < v;
        u += 1
      ) {
        const f = i.eq(u)
        const m = r[u]
        const g = ((h - f[0].swiperSlideOffset - m / 2) / m) * n.modifier
        let b = l ? p * g : 0
        let w = l ? 0 : p * g
        let y = -c * Math.abs(g)
        let x = l ? 0 : n.stretch * g
        let T = l ? n.stretch * g : 0
        Math.abs(T) < 0.001 && (T = 0),
          Math.abs(x) < 0.001 && (x = 0),
          Math.abs(y) < 0.001 && (y = 0),
          Math.abs(b) < 0.001 && (b = 0),
          Math.abs(w) < 0.001 && (w = 0)
        const E =
          'translate3d(' +
          T +
          'px,' +
          x +
          'px,' +
          y +
          'px)  rotateX(' +
          w +
          'deg) rotateY(' +
          b +
          'deg)'
        if (
          (f.transform(E),
          (f[0].style.zIndex = 1 - Math.abs(Math.round(g))),
          n.slideShadows)
        ) {
          let C = l
            ? f.find('.swiper-slide-shadow-left')
            : f.find('.swiper-slide-shadow-top')
          let S = l
            ? f.find('.swiper-slide-shadow-right')
            : f.find('.swiper-slide-shadow-bottom')
          C.length === 0 &&
            ((C = s(
              '<div class="swiper-slide-shadow-' +
                (l ? 'left' : 'top') +
                '"></div>'
            )),
            f.append(C)),
            S.length === 0 &&
              ((S = s(
                '<div class="swiper-slide-shadow-' +
                  (l ? 'right' : 'bottom') +
                  '"></div>'
              )),
              f.append(S)),
            C.length && (C[0].style.opacity = g > 0 ? g : 0),
            S.length && (S[0].style.opacity = -g > 0 ? -g : 0)
        }
      }
      ;(o.pointerEvents || o.prefixedPointerEvents) &&
        (a[0].style.perspectiveOrigin = h + 'px 50%')
    },
    setTransition(e) {
      this.slides
        .transition(e)
        .find(
          '.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left'
        )
        .transition(e)
    },
  }
  const be = {
    init() {
      const e = this.params.thumbs
      const t = this.constructor
      e.swiper instanceof t
        ? ((this.thumbs.swiper = e.swiper),
          n.extend(this.thumbs.swiper.originalParams, {
            watchSlidesProgress: !0,
            slideToClickedSlide: !1,
          }),
          n.extend(this.thumbs.swiper.params, {
            watchSlidesProgress: !0,
            slideToClickedSlide: !1,
          }))
        : n.isObject(e.swiper) &&
          ((this.thumbs.swiper = new t(
            n.extend({}, e.swiper, {
              watchSlidesVisibility: !0,
              watchSlidesProgress: !0,
              slideToClickedSlide: !1,
            })
          )),
          (this.thumbs.swiperCreated = !0)),
        this.thumbs.swiper.$el.addClass(
          this.params.thumbs.thumbsContainerClass
        ),
        this.thumbs.swiper.on('tap', this.thumbs.onThumbClick)
    },
    onThumbClick() {
      const e = this.thumbs.swiper
      if (e) {
        const t = e.clickedIndex
        const i = e.clickedSlide
        if (
          !(
            (i && s(i).hasClass(this.params.thumbs.slideThumbActiveClass)) ||
            t == null
          )
        ) {
          let a
          if (
            ((a = e.params.loop
              ? parseInt(s(e.clickedSlide).attr('data-swiper-slide-index'), 10)
              : t),
            this.params.loop)
          ) {
            let r = this.activeIndex
            this.slides.eq(r).hasClass(this.params.slideDuplicateClass) &&
              (this.loopFix(),
              (this._clientLeft = this.$wrapperEl[0].clientLeft),
              (r = this.activeIndex))
            const n = this.slides
              .eq(r)
              .prevAll('[data-swiper-slide-index="' + a + '"]')
              .eq(0)
              .index()
            const o = this.slides
              .eq(r)
              .nextAll('[data-swiper-slide-index="' + a + '"]')
              .eq(0)
              .index()
            a = void 0 === n ? o : void 0 === o ? n : o - r < r - n ? o : n
          }
          this.slideTo(a)
        }
      }
    },
    update(e) {
      const t = this.thumbs.swiper
      if (t) {
        const i =
          t.params.slidesPerView === 'auto'
            ? t.slidesPerViewDynamic()
            : t.params.slidesPerView
        if (this.realIndex !== t.realIndex) {
          let s
          let a = t.activeIndex
          if (t.params.loop) {
            t.slides.eq(a).hasClass(t.params.slideDuplicateClass) &&
              (t.loopFix(),
              (t._clientLeft = t.$wrapperEl[0].clientLeft),
              (a = t.activeIndex))
            const r = t.slides
              .eq(a)
              .prevAll('[data-swiper-slide-index="' + this.realIndex + '"]')
              .eq(0)
              .index()
            const n = t.slides
              .eq(a)
              .nextAll('[data-swiper-slide-index="' + this.realIndex + '"]')
              .eq(0)
              .index()
            s =
              void 0 === r
                ? n
                : void 0 === n
                ? r
                : n - a == a - r
                ? a
                : n - a < a - r
                ? n
                : r
          } else s = this.realIndex
          t.visibleSlidesIndexes &&
            !t.visibleSlidesIndexes.includes(s) &&
            (t.params.centeredSlides
              ? (s =
                  s > a ? s - Math.floor(i / 2) + 1 : s + Math.floor(i / 2) - 1)
              : s > a && (s = s - i + 1),
            t.slideTo(s, e ? 0 : void 0))
        }
        let o = 1
        const l = this.params.thumbs.slideThumbActiveClass
        if (
          (this.params.slidesPerView > 1 &&
            !this.params.centeredSlides &&
            (o = this.params.slidesPerView),
          t.slides.removeClass(l),
          t.params.loop || (t.params.virtual && t.params.virtual.enabled))
        )
          for (let d = 0; d < o; d += 1)
            t.$wrapperEl
              .children(
                '[data-swiper-slide-index="' + (this.realIndex + d) + '"]'
              )
              .addClass(l)
        else
          for (let h = 0; h < o; h += 1)
            t.slides.eq(this.realIndex + h).addClass(l)
      }
    },
  }
  const we = [
    R,
    q,
    K,
    U,
    Z,
    J,
    te,
    {
      name: 'mousewheel',
      params: {
        mousewheel: {
          enabled: !1,
          releaseOnEdges: !1,
          invert: !1,
          forceToAxis: !1,
          sensitivity: 1,
          eventsTarged: 'container',
        },
      },
      create() {
        n.extend(this, {
          mousewheel: {
            enabled: !1,
            enable: ie.enable.bind(this),
            disable: ie.disable.bind(this),
            handle: ie.handle.bind(this),
            handleMouseEnter: ie.handleMouseEnter.bind(this),
            handleMouseLeave: ie.handleMouseLeave.bind(this),
            lastScrollTime: n.now(),
            lastEventBeforeSnap: void 0,
            recentWheelEvents: [],
          },
        })
      },
      on: {
        init() {
          !this.params.mousewheel.enabled &&
            this.params.cssMode &&
            this.mousewheel.disable(),
            this.params.mousewheel.enabled && this.mousewheel.enable()
        },
        destroy() {
          this.params.cssMode && this.mousewheel.enable(),
            this.mousewheel.enabled && this.mousewheel.disable()
        },
      },
    },
    {
      name: 'navigation',
      params: {
        navigation: {
          nextEl: null,
          prevEl: null,
          hideOnClick: !1,
          disabledClass: 'swiper-button-disabled',
          hiddenClass: 'swiper-button-hidden',
          lockClass: 'swiper-button-lock',
        },
      },
      create() {
        n.extend(this, {
          navigation: {
            init: se.init.bind(this),
            update: se.update.bind(this),
            destroy: se.destroy.bind(this),
            onNextClick: se.onNextClick.bind(this),
            onPrevClick: se.onPrevClick.bind(this),
          },
        })
      },
      on: {
        init() {
          this.navigation.init(), this.navigation.update()
        },
        toEdge() {
          this.navigation.update()
        },
        fromEdge() {
          this.navigation.update()
        },
        destroy() {
          this.navigation.destroy()
        },
        click(e) {
          let t
          const i = this.navigation
          const a = i.$nextEl
          const r = i.$prevEl
          !this.params.navigation.hideOnClick ||
            s(e.target).is(r) ||
            s(e.target).is(a) ||
            (a
              ? (t = a.hasClass(this.params.navigation.hiddenClass))
              : r && (t = r.hasClass(this.params.navigation.hiddenClass)),
            !0 === t
              ? this.emit('navigationShow', this)
              : this.emit('navigationHide', this),
            a && a.toggleClass(this.params.navigation.hiddenClass),
            r && r.toggleClass(this.params.navigation.hiddenClass))
        },
      },
    },
    {
      name: 'pagination',
      params: {
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: !1,
          hideOnClick: !1,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: !1,
          type: 'bullets',
          dynamicBullets: !1,
          dynamicMainBullets: 1,
          formatFractionCurrent(e) {
            return e
          },
          formatFractionTotal(e) {
            return e
          },
          bulletClass: 'swiper-pagination-bullet',
          bulletActiveClass: 'swiper-pagination-bullet-active',
          modifierClass: 'swiper-pagination-',
          currentClass: 'swiper-pagination-current',
          totalClass: 'swiper-pagination-total',
          hiddenClass: 'swiper-pagination-hidden',
          progressbarFillClass: 'swiper-pagination-progressbar-fill',
          progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
          clickableClass: 'swiper-pagination-clickable',
          lockClass: 'swiper-pagination-lock',
        },
      },
      create() {
        n.extend(this, {
          pagination: {
            init: ae.init.bind(this),
            render: ae.render.bind(this),
            update: ae.update.bind(this),
            destroy: ae.destroy.bind(this),
            dynamicBulletIndex: 0,
          },
        })
      },
      on: {
        init() {
          this.pagination.init(),
            this.pagination.render(),
            this.pagination.update()
        },
        activeIndexChange() {
          this.params.loop
            ? this.pagination.update()
            : void 0 === this.snapIndex && this.pagination.update()
        },
        snapIndexChange() {
          this.params.loop || this.pagination.update()
        },
        slidesLengthChange() {
          this.params.loop &&
            (this.pagination.render(), this.pagination.update())
        },
        snapGridLengthChange() {
          this.params.loop ||
            (this.pagination.render(), this.pagination.update())
        },
        destroy() {
          this.pagination.destroy()
        },
        click(e) {
          this.params.pagination.el &&
            this.params.pagination.hideOnClick &&
            this.pagination.$el.length > 0 &&
            !s(e.target).hasClass(this.params.pagination.bulletClass) &&
            (!0 ===
            this.pagination.$el.hasClass(this.params.pagination.hiddenClass)
              ? this.emit('paginationShow', this)
              : this.emit('paginationHide', this),
            this.pagination.$el.toggleClass(this.params.pagination.hiddenClass))
        },
      },
    },
    {
      name: 'scrollbar',
      params: {
        scrollbar: {
          el: null,
          dragSize: 'auto',
          hide: !1,
          draggable: !1,
          snapOnRelease: !0,
          lockClass: 'swiper-scrollbar-lock',
          dragClass: 'swiper-scrollbar-drag',
        },
      },
      create() {
        n.extend(this, {
          scrollbar: {
            init: re.init.bind(this),
            destroy: re.destroy.bind(this),
            updateSize: re.updateSize.bind(this),
            setTranslate: re.setTranslate.bind(this),
            setTransition: re.setTransition.bind(this),
            enableDraggable: re.enableDraggable.bind(this),
            disableDraggable: re.disableDraggable.bind(this),
            setDragPosition: re.setDragPosition.bind(this),
            getPointerPosition: re.getPointerPosition.bind(this),
            onDragStart: re.onDragStart.bind(this),
            onDragMove: re.onDragMove.bind(this),
            onDragEnd: re.onDragEnd.bind(this),
            isTouched: !1,
            timeout: null,
            dragTimeout: null,
          },
        })
      },
      on: {
        init() {
          this.scrollbar.init(),
            this.scrollbar.updateSize(),
            this.scrollbar.setTranslate()
        },
        update() {
          this.scrollbar.updateSize()
        },
        resize() {
          this.scrollbar.updateSize()
        },
        observerUpdate() {
          this.scrollbar.updateSize()
        },
        setTranslate() {
          this.scrollbar.setTranslate()
        },
        setTransition(e) {
          this.scrollbar.setTransition(e)
        },
        destroy() {
          this.scrollbar.destroy()
        },
      },
    },
    {
      name: 'parallax',
      params: { parallax: { enabled: !1 } },
      create() {
        n.extend(this, {
          parallax: {
            setTransform: ne.setTransform.bind(this),
            setTranslate: ne.setTranslate.bind(this),
            setTransition: ne.setTransition.bind(this),
          },
        })
      },
      on: {
        beforeInit() {
          this.params.parallax.enabled &&
            ((this.params.watchSlidesProgress = !0),
            (this.originalParams.watchSlidesProgress = !0))
        },
        init() {
          this.params.parallax.enabled && this.parallax.setTranslate()
        },
        setTranslate() {
          this.params.parallax.enabled && this.parallax.setTranslate()
        },
        setTransition(e) {
          this.params.parallax.enabled && this.parallax.setTransition(e)
        },
      },
    },
    {
      name: 'zoom',
      params: {
        zoom: {
          enabled: !1,
          maxRatio: 3,
          minRatio: 1,
          toggle: !0,
          containerClass: 'swiper-zoom-container',
          zoomedSlideClass: 'swiper-slide-zoomed',
        },
      },
      create() {
        const e = this
        const t = {
          enabled: !1,
          scale: 1,
          currentScale: 1,
          isScaling: !1,
          gesture: {
            $slideEl: void 0,
            slideWidth: void 0,
            slideHeight: void 0,
            $imageEl: void 0,
            $imageWrapEl: void 0,
            maxRatio: 3,
          },
          image: {
            isTouched: void 0,
            isMoved: void 0,
            currentX: void 0,
            currentY: void 0,
            minX: void 0,
            minY: void 0,
            maxX: void 0,
            maxY: void 0,
            width: void 0,
            height: void 0,
            startX: void 0,
            startY: void 0,
            touchesStart: {},
            touchesCurrent: {},
          },
          velocity: {
            x: void 0,
            y: void 0,
            prevPositionX: void 0,
            prevPositionY: void 0,
            prevTime: void 0,
          },
        }
        'onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out'
          .split(' ')
          .forEach(function (i) {
            t[i] = oe[i].bind(e)
          }),
          n.extend(e, { zoom: t })
        let i = 1
        Object.defineProperty(e.zoom, 'scale', {
          get() {
            return i
          },
          set(t) {
            if (i !== t) {
              const s = e.zoom.gesture.$imageEl
                ? e.zoom.gesture.$imageEl[0]
                : void 0
              const a = e.zoom.gesture.$slideEl
                ? e.zoom.gesture.$slideEl[0]
                : void 0
              e.emit('zoomChange', t, s, a)
            }
            i = t
          },
        })
      },
      on: {
        init() {
          this.params.zoom.enabled && this.zoom.enable()
        },
        destroy() {
          this.zoom.disable()
        },
        touchStart(e) {
          this.zoom.enabled && this.zoom.onTouchStart(e)
        },
        touchEnd(e) {
          this.zoom.enabled && this.zoom.onTouchEnd(e)
        },
        doubleTap(e) {
          this.params.zoom.enabled &&
            this.zoom.enabled &&
            this.params.zoom.toggle &&
            this.zoom.toggle(e)
        },
        transitionEnd() {
          this.zoom.enabled &&
            this.params.zoom.enabled &&
            this.zoom.onTransitionEnd()
        },
        slideChange() {
          this.zoom.enabled &&
            this.params.zoom.enabled &&
            this.params.cssMode &&
            this.zoom.onTransitionEnd()
        },
      },
    },
    {
      name: 'lazy',
      params: {
        lazy: {
          enabled: !1,
          loadPrevNext: !1,
          loadPrevNextAmount: 1,
          loadOnTransitionStart: !1,
          elementClass: 'swiper-lazy',
          loadingClass: 'swiper-lazy-loading',
          loadedClass: 'swiper-lazy-loaded',
          preloaderClass: 'swiper-lazy-preloader',
        },
      },
      create() {
        n.extend(this, {
          lazy: {
            initialImageLoaded: !1,
            load: le.load.bind(this),
            loadInSlide: le.loadInSlide.bind(this),
          },
        })
      },
      on: {
        beforeInit() {
          this.params.lazy.enabled &&
            this.params.preloadImages &&
            (this.params.preloadImages = !1)
        },
        init() {
          this.params.lazy.enabled &&
            !this.params.loop &&
            this.params.initialSlide === 0 &&
            this.lazy.load()
        },
        scroll() {
          this.params.freeMode &&
            !this.params.freeModeSticky &&
            this.lazy.load()
        },
        resize() {
          this.params.lazy.enabled && this.lazy.load()
        },
        scrollbarDragMove() {
          this.params.lazy.enabled && this.lazy.load()
        },
        transitionStart() {
          this.params.lazy.enabled &&
            (this.params.lazy.loadOnTransitionStart ||
              (!this.params.lazy.loadOnTransitionStart &&
                !this.lazy.initialImageLoaded)) &&
            this.lazy.load()
        },
        transitionEnd() {
          this.params.lazy.enabled &&
            !this.params.lazy.loadOnTransitionStart &&
            this.lazy.load()
        },
        slideChange() {
          this.params.lazy.enabled && this.params.cssMode && this.lazy.load()
        },
      },
    },
    {
      name: 'controller',
      params: { controller: { control: void 0, inverse: !1, by: 'slide' } },
      create() {
        n.extend(this, {
          controller: {
            control: this.params.controller.control,
            getInterpolateFunction: de.getInterpolateFunction.bind(this),
            setTranslate: de.setTranslate.bind(this),
            setTransition: de.setTransition.bind(this),
          },
        })
      },
      on: {
        update() {
          this.controller.control &&
            this.controller.spline &&
            ((this.controller.spline = void 0), delete this.controller.spline)
        },
        resize() {
          this.controller.control &&
            this.controller.spline &&
            ((this.controller.spline = void 0), delete this.controller.spline)
        },
        observerUpdate() {
          this.controller.control &&
            this.controller.spline &&
            ((this.controller.spline = void 0), delete this.controller.spline)
        },
        setTranslate(e, t) {
          this.controller.control && this.controller.setTranslate(e, t)
        },
        setTransition(e, t) {
          this.controller.control && this.controller.setTransition(e, t)
        },
      },
    },
    {
      name: 'a11y',
      params: {
        a11y: {
          enabled: !0,
          notificationClass: 'swiper-notification',
          prevSlideMessage: 'Previous slide',
          nextSlideMessage: 'Next slide',
          firstSlideMessage: 'This is the first slide',
          lastSlideMessage: 'This is the last slide',
          paginationBulletMessage: 'Go to slide {{index}}',
        },
      },
      create() {
        const e = this
        n.extend(e, {
          a11y: {
            liveRegion: s(
              '<span class="' +
                e.params.a11y.notificationClass +
                '" aria-live="assertive" aria-atomic="true"></span>'
            ),
          },
        }),
          Object.keys(he).forEach(function (t) {
            e.a11y[t] = he[t].bind(e)
          })
      },
      on: {
        init() {
          this.params.a11y.enabled &&
            (this.a11y.init(), this.a11y.updateNavigation())
        },
        toEdge() {
          this.params.a11y.enabled && this.a11y.updateNavigation()
        },
        fromEdge() {
          this.params.a11y.enabled && this.a11y.updateNavigation()
        },
        paginationUpdate() {
          this.params.a11y.enabled && this.a11y.updatePagination()
        },
        destroy() {
          this.params.a11y.enabled && this.a11y.destroy()
        },
      },
    },
    {
      name: 'history',
      params: { history: { enabled: !1, replaceState: !1, key: 'slides' } },
      create() {
        n.extend(this, {
          history: {
            init: pe.init.bind(this),
            setHistory: pe.setHistory.bind(this),
            setHistoryPopState: pe.setHistoryPopState.bind(this),
            scrollToSlide: pe.scrollToSlide.bind(this),
            destroy: pe.destroy.bind(this),
          },
        })
      },
      on: {
        init() {
          this.params.history.enabled && this.history.init()
        },
        destroy() {
          this.params.history.enabled && this.history.destroy()
        },
        transitionEnd() {
          this.history.initialized &&
            this.history.setHistory(this.params.history.key, this.activeIndex)
        },
        slideChange() {
          this.history.initialized &&
            this.params.cssMode &&
            this.history.setHistory(this.params.history.key, this.activeIndex)
        },
      },
    },
    {
      name: 'hash-navigation',
      params: {
        hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 },
      },
      create() {
        n.extend(this, {
          hashNavigation: {
            initialized: !1,
            init: ce.init.bind(this),
            destroy: ce.destroy.bind(this),
            setHash: ce.setHash.bind(this),
            onHashCange: ce.onHashCange.bind(this),
          },
        })
      },
      on: {
        init() {
          this.params.hashNavigation.enabled && this.hashNavigation.init()
        },
        destroy() {
          this.params.hashNavigation.enabled && this.hashNavigation.destroy()
        },
        transitionEnd() {
          this.hashNavigation.initialized && this.hashNavigation.setHash()
        },
        slideChange() {
          this.hashNavigation.initialized &&
            this.params.cssMode &&
            this.hashNavigation.setHash()
        },
      },
    },
    {
      name: 'autoplay',
      params: {
        autoplay: {
          enabled: !1,
          delay: 3e3,
          waitForTransition: !0,
          disableOnInteraction: !0,
          stopOnLastSlide: !1,
          reverseDirection: !1,
        },
      },
      create() {
        const e = this
        n.extend(e, {
          autoplay: {
            running: !1,
            paused: !1,
            run: ue.run.bind(e),
            start: ue.start.bind(e),
            stop: ue.stop.bind(e),
            pause: ue.pause.bind(e),
            onVisibilityChange() {
              document.visibilityState === 'hidden' &&
                e.autoplay.running &&
                e.autoplay.pause(),
                document.visibilityState === 'visible' &&
                  e.autoplay.paused &&
                  (e.autoplay.run(), (e.autoplay.paused = !1))
            },
            onTransitionEnd(t) {
              e &&
                !e.destroyed &&
                e.$wrapperEl &&
                t.target === this &&
                (e.$wrapperEl[0].removeEventListener(
                  'transitionend',
                  e.autoplay.onTransitionEnd
                ),
                e.$wrapperEl[0].removeEventListener(
                  'webkitTransitionEnd',
                  e.autoplay.onTransitionEnd
                ),
                (e.autoplay.paused = !1),
                e.autoplay.running ? e.autoplay.run() : e.autoplay.stop())
            },
          },
        })
      },
      on: {
        init() {
          this.params.autoplay.enabled &&
            (this.autoplay.start(),
            document.addEventListener(
              'visibilitychange',
              this.autoplay.onVisibilityChange
            ))
        },
        beforeTransitionStart(e, t) {
          this.autoplay.running &&
            (t || !this.params.autoplay.disableOnInteraction
              ? this.autoplay.pause(e)
              : this.autoplay.stop())
        },
        sliderFirstMove() {
          this.autoplay.running &&
            (this.params.autoplay.disableOnInteraction
              ? this.autoplay.stop()
              : this.autoplay.pause())
        },
        touchEnd() {
          this.params.cssMode &&
            this.autoplay.paused &&
            !this.params.autoplay.disableOnInteraction &&
            this.autoplay.run()
        },
        destroy() {
          this.autoplay.running && this.autoplay.stop(),
            document.removeEventListener(
              'visibilitychange',
              this.autoplay.onVisibilityChange
            )
        },
      },
    },
    {
      name: 'effect-fade',
      params: { fadeEffect: { crossFade: !1 } },
      create() {
        n.extend(this, {
          fadeEffect: {
            setTranslate: ve.setTranslate.bind(this),
            setTransition: ve.setTransition.bind(this),
          },
        })
      },
      on: {
        beforeInit() {
          if (this.params.effect === 'fade') {
            this.classNames.push(this.params.containerModifierClass + 'fade')
            const e = {
              slidesPerView: 1,
              slidesPerColumn: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: !0,
              spaceBetween: 0,
              virtualTranslate: !0,
            }
            n.extend(this.params, e), n.extend(this.originalParams, e)
          }
        },
        setTranslate() {
          this.params.effect === 'fade' && this.fadeEffect.setTranslate()
        },
        setTransition(e) {
          this.params.effect === 'fade' && this.fadeEffect.setTransition(e)
        },
      },
    },
    {
      name: 'effect-cube',
      params: {
        cubeEffect: {
          slideShadows: !0,
          shadow: !0,
          shadowOffset: 20,
          shadowScale: 0.94,
        },
      },
      create() {
        n.extend(this, {
          cubeEffect: {
            setTranslate: fe.setTranslate.bind(this),
            setTransition: fe.setTransition.bind(this),
          },
        })
      },
      on: {
        beforeInit() {
          if (this.params.effect === 'cube') {
            this.classNames.push(this.params.containerModifierClass + 'cube'),
              this.classNames.push(this.params.containerModifierClass + '3d')
            const e = {
              slidesPerView: 1,
              slidesPerColumn: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: !0,
              resistanceRatio: 0,
              spaceBetween: 0,
              centeredSlides: !1,
              virtualTranslate: !0,
            }
            n.extend(this.params, e), n.extend(this.originalParams, e)
          }
        },
        setTranslate() {
          this.params.effect === 'cube' && this.cubeEffect.setTranslate()
        },
        setTransition(e) {
          this.params.effect === 'cube' && this.cubeEffect.setTransition(e)
        },
      },
    },
    {
      name: 'effect-flip',
      params: { flipEffect: { slideShadows: !0, limitRotation: !0 } },
      create() {
        n.extend(this, {
          flipEffect: {
            setTranslate: me.setTranslate.bind(this),
            setTransition: me.setTransition.bind(this),
          },
        })
      },
      on: {
        beforeInit() {
          if (this.params.effect === 'flip') {
            this.classNames.push(this.params.containerModifierClass + 'flip'),
              this.classNames.push(this.params.containerModifierClass + '3d')
            const e = {
              slidesPerView: 1,
              slidesPerColumn: 1,
              slidesPerGroup: 1,
              watchSlidesProgress: !0,
              spaceBetween: 0,
              virtualTranslate: !0,
            }
            n.extend(this.params, e), n.extend(this.originalParams, e)
          }
        },
        setTranslate() {
          this.params.effect === 'flip' && this.flipEffect.setTranslate()
        },
        setTransition(e) {
          this.params.effect === 'flip' && this.flipEffect.setTransition(e)
        },
      },
    },
    {
      name: 'effect-coverflow',
      params: {
        coverflowEffect: {
          rotate: 50,
          stretch: 0,
          depth: 100,
          modifier: 1,
          slideShadows: !0,
        },
      },
      create() {
        n.extend(this, {
          coverflowEffect: {
            setTranslate: ge.setTranslate.bind(this),
            setTransition: ge.setTransition.bind(this),
          },
        })
      },
      on: {
        beforeInit() {
          this.params.effect === 'coverflow' &&
            (this.classNames.push(
              this.params.containerModifierClass + 'coverflow'
            ),
            this.classNames.push(this.params.containerModifierClass + '3d'),
            (this.params.watchSlidesProgress = !0),
            (this.originalParams.watchSlidesProgress = !0))
        },
        setTranslate() {
          this.params.effect === 'coverflow' &&
            this.coverflowEffect.setTranslate()
        },
        setTransition(e) {
          this.params.effect === 'coverflow' &&
            this.coverflowEffect.setTransition(e)
        },
      },
    },
    {
      name: 'thumbs',
      params: {
        thumbs: {
          swiper: null,
          slideThumbActiveClass: 'swiper-slide-thumb-active',
          thumbsContainerClass: 'swiper-container-thumbs',
        },
      },
      create() {
        n.extend(this, {
          thumbs: {
            swiper: null,
            init: be.init.bind(this),
            update: be.update.bind(this),
            onThumbClick: be.onThumbClick.bind(this),
          },
        })
      },
      on: {
        beforeInit() {
          const e = this.params.thumbs
          e && e.swiper && (this.thumbs.init(), this.thumbs.update(!0))
        },
        slideChange() {
          this.thumbs.swiper && this.thumbs.update()
        },
        update() {
          this.thumbs.swiper && this.thumbs.update()
        },
        resize() {
          this.thumbs.swiper && this.thumbs.update()
        },
        observerUpdate() {
          this.thumbs.swiper && this.thumbs.update()
        },
        setTransition(e) {
          const t = this.thumbs.swiper
          t && t.setTransition(e)
        },
        beforeDestroy() {
          const e = this.thumbs.swiper
          e && this.thumbs.swiperCreated && e && e.destroy()
        },
      },
    },
  ]
  return (
    void 0 === W.use &&
      ((W.use = W.Class.use), (W.installModule = W.Class.installModule)),
    W.use(we),
    W
  )
})
// # sourceMappingURL=swiper.min.js.map
